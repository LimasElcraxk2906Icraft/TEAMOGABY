<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Compost 2D Estilo Terraria</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos generales del cuerpo */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0f2f7; /* Fondo azul claro */
            display: flex;
            flex-direction: column; /* Apilar verticalmente */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none; /* Prevenir selecci√≥n de texto durante arrastrar y soltar */
        }
        /* Contenedor principal del juego */
        .game-container {
            background-color: #ffffff;
            border-radius: 1rem; /* Bordes redondeados */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            max-width: 100vw; /* Ancho responsivo */
            overflow: auto; /* Permitir desplazamiento dentro del contenedor si el contenido excede */
            box-sizing: border-box;
            position: relative; /* Para el posicionamiento absoluto de la caja de di√°logo */
            z-index: 10; /* Establecer expl√≠citamente el z-index para capas */
        }
        /* Estilos del canvas del juego */
        canvas {
            background-color: #f5f5dc; /* Beige para el suelo */
            border: 2px solid #8b4513; /* Borde marr√≥n para la casa */
            border-radius: 0.5rem;
            display: block;
            touch-action: none; /* Prevenir acciones t√°ctiles predeterminadas como desplazarse/hacer zoom */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        /* Informaci√≥n del juego (UI superior) */
        .game-info {
            width: 100%;
            display: flex;
            justify-content: space-around;
            padding: 0.5rem 0;
            font-size: 1.1rem;
            color: #333;
            flex-wrap: wrap; /* Permitir ajuste de l√≠nea en pantallas peque√±as */
            gap: 0.5rem;
        }
        .game-info div {
            padding: 0.3rem 0.8rem;
            background-color: #f0f4c3; /* Fondo amarillo claro para la informaci√≥n */
            border-radius: 0.5rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        /* Controles (botones de movimiento) */
        .controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-button {
            background-color: #4CAF50; /* Verde */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.75rem;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
        .control-button:active {
            background-color: #388e3c;
            transform: translateY(0);
        }
        /* Caja de mensajes temporales */
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1.5rem 2rem;
            border-radius: 1rem;
            text-align: center;
            font-size: 1.5rem;
            z-index: 1000;
            display: none; /* Oculto por defecto */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        /* Estilos para la superposici√≥n de preguntas */
        .question-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            flex-direction: column;
            padding: 2rem;
            box-sizing: border-box;
        }
        .question-box {
            background-color: #fff;
            color: #333;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            max-width: 80%;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }
        .question-text {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            font-weight: bold;
        }
        .options-container {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            width: 100%;
        }
        .option-button {
            background-color: #a8e6cf; /* Verde claro */
            color: #333;
            padding: 0.8rem 1.2rem;
            border: 2px solid #388e3c;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            text-align: left;
        }
        .option-button:hover {
            background-color: #8bc34a;
            transform: translateY(-2px);
        }
        .option-button:active {
            background-color: #689f38;
            transform: translateY(0);
        }
        .option-button.selected {
            background-color: #4CAF50; /* Verde cuando est√° seleccionado */
            color: white;
            border-color: #388e3c;
        }
        .question-timer {
            font-size: 1.5rem;
            margin-top: 1rem;
            color: #ff4500; /* Rojo anaranjado */
            font-weight: bold;
        }
        /* Superposici√≥n de carga */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            font-size: 2rem;
            color: #333;
            flex-direction: column;
            gap: 1rem;
        }
        #loadingOverlay #loadingProgress {
            font-size: 1.5rem;
            color: #666;
        }

        /* Estilos de la caja de di√°logo */
        #dialogueBox {
            position: absolute;
            bottom: 2rem; /* Posicionar encima de los controles */
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #4CAF50;
            border-radius: 1rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            display: none; /* Oculto por defecto */
            flex-direction: column;
            gap: 1rem;
            z-index: 1500;
            animation: fadeInUp 0.3s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        #dialogueText {
            font-size: 1.2rem;
            color: #333;
            min-height: 3em; /* Asegurar altura consistente */
        }

        #dialogueOptions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .dialogue-option-button {
            background-color: #81C784; /* Verde claro */
            color: #333;
            padding: 0.7rem 1.2rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .dialogue-option-button:hover {
            background-color: #66BB6A;
            transform: translateY(-1px);
        }
        .dialogue-option-button:active {
            background-color: #4CAF50;
            transform: translateY(0);
        }
        /* Estilos de la barra de salud */
        .health-bar-container {
            width: 100px;
            height: 10px;
            background-color: #ccc;
            border: 1px solid #333;
            border-radius: 5px;
            overflow: hidden;
        }
        .health-bar {
            height: 100%;
            background-color: #ff4500; /* Rojo */
            transition: width 0.2s ease-in-out;
        }

        /* Estilos del inventario (para la superposici√≥n de inventario completo) */
        #inventoryOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 1rem;
            padding: 1.5rem;
            display: none; /* Oculto por defecto */
            flex-direction: column;
            gap: 1rem;
            z-index: 2500;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 1.2rem;
            min-width: 300px;
        }
        .inventory-hotbar-grid {
            display: grid;
            grid-template-columns: repeat(4, 60px); /* 4 columnas para la barra de acceso r√°pido */
            gap: 10px;
            justify-content: center; /* Centrar la barra de acceso r√°pido */
        }
        .inventory-storage-grid {
            display: grid;
            grid-template-columns: repeat(3, 60px); /* 3 columnas para el almacenamiento */
            gap: 10px;
            justify-content: center; /* Centrar el almacenamiento en la interfaz de usuario del inventario */
        }

        /* Estilos de las ranuras del inventario (tanto para la barra de acceso r√°pido dibujada en canvas como para la superposici√≥n de inventario HTML) */
        .inventory-slot {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.2); /* M√°s oscuro para las ranuras reales */
            border: 2px solid #66BB6A; /* Borde verde */
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: background-color 0.1s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .inventory-slot:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .inventory-slot.active {
            border-color: #FFEB3B; /* Amarillo para la ranura activa */
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
            transform: scale(1.05); /* Ligeramente m√°s grande la ranura activa */
        }

        .inventory-slot .item-emoji {
            font-size: 2.5rem;
            line-height: 1;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));
        }

        .inventory-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        #draggedItemVisual {
            position: fixed; /* Posici√≥n fija relativa a la ventana de visualizaci√≥n */
            pointer-events: none; /* Ignorar eventos del rat√≥n en este elemento */
            z-index: 3000; /* Encima de todo */
            display: none; /* Oculto por defecto */
            transform: translate(-50%, -50%); /* Centrar en el cursor */
            font-size: 2.5rem;
            line-height: 1;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 5px;
        }

        /* Estilos para los n√∫meros de da√±o flotantes */
        .damage-number {
            position: absolute;
            color: red;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            animation: floatUpFadeOut 1s forwards;
            pointer-events: none; /* Make sure it doesn't block clicks */
            z-index: 2000; /* Above game elements but below overlays */
        }

        @keyframes floatUpFadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-30px);
            }
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 1rem;
                gap: 0.5rem;
            }
            canvas {
                width: 100%;
                height: auto;
            }
            .game-info div {
                font-size: 0.9rem;
                padding: 0.2rem 0.5rem;
            }
            .controls {
                gap: 0.5rem;
            }
            .control-button {
                padding: 0.6rem 1.2rem;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        Cargando recursos del juego... <span id="loadingProgress">0/0</span>
    </div>

    <div class="game-container">
        <h1 class="text-3xl font-bold text-green-700 mb-4">Juego de Compost Casero</h1>
        <div class="game-info">
            <div>Compost: <span id="compost-count">0</span> / <span id="compost-max">5</span></div>
            <div>Estado: <span id="compost-state">Esperando tierra</span></div>
            <div>D√≠a: <span id="day-counter">1</span> / <span id="total-days">28</span></div>
            <div>Tiempo restante: <span id="day-timer">05:00</span></div>
            <div>Fase: <span id="phase-indicator">D√≠a</span></div>
            <div>Salud: <span id="health-value">100</span>
                <div class="health-bar-container">
                    <div id="health-bar" class="health-bar" style="width: 100%;"></div>
                </div>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <button id="up-button" class="control-button">‚ñ≤</button>
            <button id="left-button" class="control-button">‚óÄ</button>
            <button id="down-button" class="control-button">‚ñº</button>
            <button id="right-button" class="control-button">‚ñ∂</button>
            <button id="action-button" class="control-button">Acci√≥n (F)</button>
        </div>
    </div>

    <div id="messageBox" class="message-box"></div>

    <div id="questionOverlay" class="question-overlay" style="display: none;">
        <div class="question-box">
            <div class="question-text" id="questionText"></div>
            <div class="options-container" id="optionsContainer">
                </div>
            <div class="question-timer" id="questionTimer"></div>
        </div>
    </div>

    <!-- Nueva caja de di√°logo -->
    <div id="dialogueBox" style="display: none;">
        <div id="dialogueText"></div>
        <div id="dialogueOptions"></div>
    </div>

    <!-- Superposici√≥n del inventario (para inventario completo) -->
    <div id="inventoryOverlay" style="display: none;">
        <h2 class="text-2xl font-bold mb-4 text-center">Inventario</h2>
        <div class="inventory-hotbar-grid" id="fullInventoryHotbarSlots">
            <!-- Ranuras de la barra de acceso r√°pido (se generar√°n din√°micamente aqu√≠) -->
        </div>
        <h3 class="text-xl font-bold mt-4 mb-2 text-center">Almacenamiento</h3>
        <div class="inventory-storage-grid" id="storageSlots">
            <!-- Las ranuras de almacenamiento se generar√°n din√°micamente aqu√≠ -->
        </div>
    </div>

    <!-- Elemento visual para el objeto arrastrado -->
    <div id="draggedItemVisual" style="display: none;"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingProgressSpan = document.getElementById('loadingProgress');
        const gameContainer = document.querySelector('.game-container'); // Get the game container for damage numbers

        // Desactivar suavizado de im√°genes para un aspecto pixelado
        ctx.imageSmoothingEnabled = false;

        // Definiciones de tama√±o del juego
        const TILE_SIZE = 20; // Tama√±o de cada tile en p√≠xeles
        const ACTUAL_CANVAS_WIDTH = 800; // Ancho visible del canvas
        const ACTUAL_CANVAS_HEIGHT = 600; // Alto visible del canvas

        // Establecer el tama√±o del canvas
        canvas.width = ACTUAL_CANVAS_WIDTH;
        canvas.height = ACTUAL_CANVAS_HEIGHT;

        const MAP_WIDTH = 140; // Ancho del mapa en tiles
        const MAP_HEIGHT = 100; // Alto del mapa en tiles

        // Crear un canvas fuera de pantalla para el mapa est√°tico
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');
        offscreenCanvas.width = MAP_WIDTH * TILE_SIZE;
        offscreenCanvas.height = MAP_HEIGHT * TILE_SIZE;
        offscreenCtx.imageSmoothingEnabled = false; // Desactivar suavizado tambi√©n para el offscreen canvas

        // Constantes para dibujar la barra de acceso r√°pido
        const HOTBAR_SLOT_SIZE = 60; // Tama√±o de las ranuras para mejor interacci√≥n t√°ctil
        const HOTBAR_PADDING = 10; // Relleno alrededor de la barra de acceso r√°pido
        const HOTBAR_SLOT_SPACING = 10; // Espacio entre ranuras de la barra de acceso r√°pido
        const HOTBAR_WIDTH = (4 * HOTBAR_SLOT_SIZE) + (3 * HOTBAR_SLOT_SPACING) + (HOTBAR_PADDING * 2); // Ancho total de la barra de acceso r√°pido
        const HOTBAR_HEIGHT = HOTBAR_SLOT_SIZE + (HOTBAR_PADDING * 2); // Alto total de la barra de acceso r√°pido
        const HOTBAR_START_X = (ACTUAL_CANVAS_WIDTH - HOTBAR_WIDTH) / 2; // Posici√≥n X inicial de la barra de acceso r√°pido (centrada)
        const HOTBAR_START_Y = ACTUAL_CANVAS_HEIGHT - HOTBAR_HEIGHT - 20; // Posici√≥n Y inicial de la barra de acceso r√°pido (encima de los controles)

        // Dise√±o original de la casa
        const originalHouseLayout = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 16, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 3, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 4, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1],
            [1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 6, 6, 5, 6, 6, 6, 2, 6, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // Objeto jugador
        const player = {
            x: 39, // Posici√≥n X inicial
            y: 32, // Posici√≥n Y inicial
            targetX: 39, // Posici√≥n X objetivo para movimiento suave
            targetY: 32, // Posici√≥n Y objetivo para movimiento suave
            speed: 0.015, // Velocidad de movimiento del jugador
            direction: 'right', // Direcci√≥n del jugador: 'left' o 'right'. Asumo player.png por defecto mira a la DERECHA.
            health: 100, // Salud actual del jugador
            maxHealth: 100, // Salud m√°xima del jugador
            healthRegenRate: 0.5, // Puntos de salud por segundo
            lastHealthRegenTime: 0, // √öltima vez que se regener√≥ salud
            inventory: Array(10).fill(null), // Inventario: 4 ranuras de barra de acceso r√°pido (0-3), 6 ranuras de almacenamiento (4-9)
            activeSlotIndex: 0, // Ranura de la barra de acceso r√°pido actualmente seleccionada (0-3)
            attackCooldown: 500, // Tiempo de reutilizaci√≥n del ataque del jugador en ms
            lastAttackTime: 0, // √öltima vez que el jugador atac√≥
        };

        // Definir el desplazamiento de la casa para la generaci√≥n del mapa
        const houseOffsetX = 30;
        const houseOffsetY = 30;

        // Punto de reaparici√≥n del jugador
        const respawnPoint = {
            x: houseOffsetX + Math.floor(originalHouseLayout[0].length / 2),
            y: houseOffsetY + Math.floor(originalHouseLayout.length / 2)
        };

        // Pila de compost
        const compostPile = {
            x: houseOffsetX + 22, // Posici√≥n X
            y: houseOffsetY + 12, // Posici√≥n Y
            count: 0, // Cantidad actual de compost
            maxCount: 5, // Cantidad m√°xima de compost
        };

        // M√°quina de estados del compost
        const COMPOST_STATES = {
            NEEDS_SOIL: 'needs_soil', // Necesita tierra
            NEEDS_MATERIAL: 'needs_material', // Necesita material org√°nico
            NEEDS_WATER: 'needs_water', // Necesita agua
            NEEDS_STIR: 'needs_stir', // Necesita ser revuelto
            FULL: 'full' // Compost listo
        };
        let compostState = COMPOST_STATES.NEEDS_SOIL; // Estado inicial del compost

        // Tipos de materiales, sus preguntas e URLs de im√°genes
        const materials = {
            soil: { color: '#8B4513', emoji: 'ü™®', type: 'brown', challenge: false, imageUrl: 'assets/tierra.png', displayName: 'tierra', stackable: true, maxStack: 10 },
            eggshells: {
                color: '#F0F8FF', emoji: 'ü•ö', type: 'green', challenge: true, imageUrl: 'assets/huevo.png', displayName: 'c√°scara de huevo', stackable: true, maxStack: 10, questions: [
                    { text: '¬øQu√© nutriente principal aportan las c√°scaras de huevo al compost?', options: ['A) Nitr√≥geno', 'B) F√≥sforo', 'C) Calcio', 'D) Potasio'], correctOptionIndex: 2 },
                    { text: 'Para una mejor descomposici√≥n, ¬øc√≥mo deben a√±adirse las c√°scaras de huevo al compost?', options: ['A) Enteras', 'B) Trituradas', 'C) Hervidas', 'D) Congeladas'], correctOptionIndex: 1 },
                    { text: '¬øEs cierto que las c√°scaras de huevo ayudan a reducir la acidez del compost?', options: ['A) S√≠', 'B) No'], correctOptionIndex: 0 },
                    { text: 'Adem√°s de calcio, ¬øqu√© otro elemento traza importante aportan las c√°scaras de huevo?', options: ['A) Hierro', 'B) Magnesio', 'C) Zinc', 'D) Todos los anteriores'], correctOptionIndex: 3 },
                    { text: '¬øCu√°l es la principal ventaja de a√±adir c√°scaras de huevo al compost?', options: ['A) Acelera la descomposici√≥n', 'B) Aporta nutrientes esenciales', 'C) Repele plagas', 'D) Mejora el olor'], correctOptionIndex: 1 }
                ]
            },
            bananaPeels: {
                color: '#FFD700', emoji: 'üçå', type: 'green', challenge: true, imageUrl: 'assets/platano.png', displayName: 'c√°scara de banana', stackable: true, maxStack: 10, questions: [
                    { text: '¬øQu√© nutriente principal aportan las c√°scaras de pl√°tano al compost?', options: ['A) Magnesio', 'B) Potasio', 'C) Hierro', 'D) Boro'], correctOptionIndex: 1 },
                    { text: 'Las c√°scaras de pl√°tano son consideradas un material...', options: ['A) Carbonado', 'B) Nitrogenado', 'C) Neutro', 'D) T√≥xico'], correctOptionIndex: 1 },
                    { text: '¬øAyudan las c√°scaras de pl√°tano a atraer lombrices al compost?', options: ['A) S√≠', 'B) No'], correctOptionIndex: 0 },
                    { text: '¬øEs necesario cortar las c√°scaras de pl√°tano antes de compostarlas?', options: ['A) S√≠, para acelerar la descomposici√≥n', 'B) No, se descomponen igual', 'C) Solo si est√°n verdes', 'D) Solo si est√°n secas'], correctOptionIndex: 0 },
                    { text: '¬øLas c√°scaras de pl√°tano son un material "verde" o "marr√≥n" en el compostaje?', options: ['A) Verde', 'B) Marr√≥n', 'C) Ambos', 'D) Ninguno'], correctOptionIndex: 0 }
                ]
            },
            orangePeels: {
                color: '#FFA500', emoji: 'üçä', type: 'green', challenge: true, imageUrl: 'assets/naranja.png', displayName: 'c√°scara de naranja', stackable: true, maxStack: 10, questions: [
                    { text: '¬øQu√© tipo de aceites contienen las c√°scaras de c√≠tricos que pueden ralentizar la descomposici√≥n?', options: ['A) Aceites esenciales', 'B) Aceites minerales', 'C) Aceites vegetales', 'D) Aceites lubricantes'], correctOptionIndex: 0 },
                    { text: 'Para a√±adir c√°scaras de naranja al compost, ¬øes mejor cortarlas en trozos peque√±os?', options: ['A) S√≠', 'B) No'], correctOptionIndex: 0 },
                    { text: 'Las c√°scaras de naranja son un material con un alto contenido de...', options: ['A) Prote√≠nas', 'B) Az√∫cares', 'C) Celulosa', 'D) Grasas'], correctOptionIndex: 2 },
                    { text: '¬øCu√°l es el efecto principal de los aceites c√≠tricos en el compost?', options: ['A) Atraen insectos', 'B) Ralentizan la descomposici√≥n', 'C) Aceleran la descomposici√≥n', 'D) Mejoran el olor'], correctOptionIndex: 1 },
                    { text: '¬øEs recomendable a√±adir grandes cantidades de c√°scaras de c√≠tricos al compost de una sola vez?', options: ['A) S√≠, sin problema', 'B) No, pueden acidificar el compost', 'C) Solo si est√°n secas', 'D) Solo si est√°n trituradas'], correctOptionIndex: 1 }
                ]
            },
            foodScraps: {
                color: '#A9A9A9', emoji: 'üçΩÔ∏è', type: 'green', challenge: true, imageUrl: 'assets/comida.png', displayName: 'sobras de comida', stackable: true, maxStack: 10, questions: [
                    { text: '¬øQu√© tipo de sobras de alimentos NO se deben a√±adir al compost casero?', options: ['A) Frutas y verduras', 'B) C√°scaras de huevo', 'C) Carnes y l√°cteos', 'D) Granos cocidos'], correctOptionIndex: 2 },
                    { text: 'Las sobras de pan y pasta son materiales principalmente...', options: ['A) Nitrogenados', 'B) Carbonados', 'C) √Åcidos', 'D) B√°sicos'], correctOptionIndex: 1 },
                    { text: '¬øEs recomendable enterrar las sobras de alimentos en el centro del compost?', options: ['A) S√≠, para evitar plagas', 'B) No, se pudren', 'C) Solo si son l√≠quidas', 'D) Solo en invierno'], correctOptionIndex: 0 },
                    { text: '¬øQu√© se debe hacer con las sobras de alimentos antes de a√±adirlas al compost para una mejor descomposici√≥n?', options: ['A) Congelarlas', 'B) Cocinarlas', 'C) Cortarlas en trozos peque√±os', 'D) Secarlas al sol'], correctOptionIndex: 2 },
                    { text: '¬øPor qu√© no se deben a√±adir carnes y l√°cteos al compost casero?', options: ['A) Huelen mal', 'B) Atraen plagas y roedores', 'C) No se descomponen', 'D) Son t√≥xicos para las plantas'], correctOptionIndex: 1 }
                ]
            },
            cebolla: {
                color: '#FFDAB9', emoji: 'üßÖ', type: 'green', challenge: true, imageUrl: 'assets/cebolla.png', displayName: 'cebolla', stackable: true, maxStack: 10, questions: [
                    { text: '¬øQu√© componente de la cebolla puede ralentizar la descomposici√≥n en el compost?', options: ['A) Az√∫cares', 'B) Compuestos de azufre', 'C) Agua', 'D) Fibra'], correctOptionIndex: 1 },
                    { text: '¬øEs recomendable a√±adir grandes cantidades de cebolla cruda al compost de una sola vez?', options: ['A) S√≠, es muy beneficioso', 'B) No, puede atraer plagas y olores', 'C) Solo si est√° cocida', 'D) Solo en invierno'], correctOptionIndex: 1 },
                    { text: 'Para una mejor descomposici√≥n, ¬øc√≥mo es mejor a√±adir la cebolla al compost?', options: ['A) Entera', 'B) Cortada en trozos peque√±os', 'C) Hervida', 'D) Seca'], correctOptionIndex: 1 },
                    { text: '¬øLas cebollas son un material "verde" o "marr√≥n" en el compostaje?', options: ['A) Verde', 'B) Marr√≥n', 'C) Ambos', 'D) Ninguno'], correctOptionIndex: 0 },
                    { text: '¬øQu√© tipo de material se debe mezclar con la cebolla en el compost para equilibrar la relaci√≥n carbono-nitr√≥geno?', options: ['A) M√°s cebolla', 'B) Restos de fruta', 'C) Materiales ricos en carbono (marr√≥n)', 'D) Agua'], correctOptionIndex: 2 }
                ]
            },
            water: { color: '#87CEEB', emoji: 'üíß', type: 'liquid', challenge: false, imageUrl: 'assets/agua.png', displayName: 'agua', stackable: true, maxStack: 10 },
            
            sword: { color: '#A9A9A9', emoji: 'üó°Ô∏è', type: 'weapon', challenge: false, imageUrl: 'assets/sword.png', displayName: 'espada', stackable: false, damage: 30 },
            shovel: { color: '#B0885F', emoji: ' ü™ö', type: 'tool', challenge: false, imageUrl: 'assets/shovel.png', displayName: 'Pala', stackable: false },
            wateringCan: { color: '#6A5ACD', emoji: ' üö∞', type: 'tool', challenge: false, imageUrl: 'assets/watering_can.png', displayName: 'Regadera', stackable: false },

            // Objetos que crecen (frutas/verduras/hierbas)
            carrot: { color: '#FFA500', emoji: 'ü•ï', type: 'fruit', challenge: false, imageUrl: 'assets/carrot.png', displayName: 'zanahoria', stackable: true, maxStack: 10 },
            tomato: { color: '#FF6347', emoji: 'üçÖ', type: 'fruit', challenge: false, imageUrl: 'assets/tomato.png', displayName: 'tomate', stackable: true, maxStack: 10 },
            hierbabuena: { id: 'hierbabuena', displayName: 'Hierbabuena', emoji: 'üåø', type: 'herb', imageUrl: 'assets/hierbabuena.png', stackable: true, maxStack: 10 },
            oregano: { id: 'oregano', displayName: 'Or√©gano', emoji: 'üçÉ', type: 'herb', imageUrl: 'assets/oregano.png', stackable: true, maxStack: 10 },
            romero: { id: 'romero', displayName: 'Romero', emoji: 'üå≤', type: 'herb', imageUrl: 'assets/romero.png', stackable: true, maxStack: 10 },
            albahaca: { id: 'albahaca', displayName: 'Albahaca', emoji: 'üå±', type: 'herb', imageUrl: 'assets/albahaca.png', stackable: true, maxStack: 10 },
            cilantro: { id: 'cilantro', displayName: 'Cilantro', emoji: 'üçÄ', type: 'herb', imageUrl: 'assets/cilantro.png', stackable: true, maxStack: 10 },
            cilantroCimarron: { id: 'cilantroCimarron', displayName: 'Cilantro Cimarr√≥n', emoji: 'üåæ', type: 'herb', imageUrl: 'assets/cilantro_cimarron.png', stackable: true, maxStack: 10 },

            // Semillas (objetos que se plantan y "crecen a" otros objetos)
            carrotSeed: { color: '#FFA500', emoji: 'ü•ï', type: 'seed', growsTo: 'carrot', challenge: false, imageUrl: 'assets/carrot_seed.png', displayName: 'semilla de zanahoria', stackable: true, maxStack: 10, growthTime: 3 }, // growthTime in days
            tomatoSeed: { color: '#FF6347', emoji: 'üçÖ', type: 'seed', growsTo: 'tomato', challenge: false, imageUrl: 'assets/tomato_seed.png', displayName: 'semilla de tomate', stackable: true, maxStack: 10, growthTime: 4 }, // growthTime in days
            seed_hierbabuena: { id: 'seed_hierbabuena', displayName: 'Semilla de Hierbabuena', emoji: 'üå±', type: 'seed', growsTo: 'hierbabuena', challenge: false, imageUrl: 'assets/seed_hierbabuena.png', stackable: true, maxStack: 10, growthTime: 2 },
            seed_oregano: { id: 'seed_oregano', displayName: 'Semilla de Or√©gano', emoji: 'üåø', type: 'seed', growsTo: 'oregano', challenge: false, imageUrl: 'assets/seed_oregano.png', stackable: true, maxStack: 10, growthTime: 3 },
            seed_romero: { id: 'seed_romero', displayName: 'Semilla de Romero', emoji: 'üå≤', type: 'seed', growsTo: 'romero', challenge: false, imageUrl: 'assets/seed_romero.png', stackable: true, maxStack: 10, growthTime: 5 },
            seed_albahaca: { id: 'seed_albahaca', displayName: 'Semilla de Albahaca', emoji: 'üçÉ', type: 'seed', growsTo: 'albahaca', challenge: false, imageUrl: 'assets/seed_albahaca.png', stackable: true, maxStack: 10, growthTime: 2 },
            seed_cilantro: { id: 'seed_cilantro', displayName: 'Semilla de Cilantro', emoji: 'üçÄ', type: 'seed', growsTo: 'cilantro', challenge: false, imageUrl: 'assets/seed_cilantro.png', stackable: true, maxStack: 10, growthTime: 1 }, // Cilantro grows fast!
            seed_cilantroCimarron: { id: 'seed_cilantroCimarron', displayName: 'Semilla de Cilantro Cimarr√≥n', emoji: 'üåæ', type: 'seed', growsTo: 'cilantroCimarron', challenge: false, imageUrl: 'assets/seed_cilantro_cimarron.png', stackable: true, maxStack: 10, growthTime: 4 },
        };

        // Global variables for asset loading
        const loadedImages = {}; // Stores loaded images
        const imageLoadedSuccessfully = {}; // Indicates if an image loaded successfully
        let assetsToLoad = 0; // Counter for assets to load
        let assetsLoaded = 0; // Counter for loaded assets
        let gameInitialized = false; // Flag to check if game has been initialized

        // --- Definici√≥n de todas las URLs de im√°genes a cargar ---
        const imageUrlsToLoad = [
            'assets/player.png',
            'assets/compost_bin.png', // Assuming you have an image for the compost bin
            'assets/tierra.png', 
            'assets/huevo.png', 
            'assets/platano.png', 
            'assets/naranja.png', 
            'assets/comida.png', 
            'assets/cebolla.png',
            'assets/agua.png', 
            'assets/sword.png',
            'assets/shovel.png', 
            'assets/watering_can.png', 
            'assets/carrot.png', 
            'assets/tomato.png', 
            'assets/hierbabuena.png', 
            'assets/oregano.png', 
            'assets/romero.png', 
            'assets/albahaca.png', 
            'assets/cilantro.png', 
            'assets/cilantro_cimarron.png', 
            'assets/carrot_seed.png', 
            'assets/tomato_seed.png', 
            'assets/seed_hierbabuena.png', 
            'assets/seed_oregano.png', 
            'assets/seed_romero.png', 
            'assets/seed_albahaca.png', 
            'assets/seed_cilantro.png', 
            'assets/seed_cilantro_cimarron.png', 
        ];
        assetsToLoad = imageUrlsToLoad.length; // El n√∫mero total de assets a cargar

        // Update initial loading progress display
        loadingProgressSpan.textContent = `${assetsLoaded}/${assetsToLoad}`;


        const monsterTypes = {
            slime: { color: '#76FF03', emoji: 'ü¶†', health: 30, damage: 5, speed: 0.005, attackCooldown: 1000, hitFlashTime: 200, drop: { type: 'seed', count: 1 } },
            goblin: { color: '#8B0000', emoji: 'üëπ', health: 50, damage: 8, speed: 0.007, attackCooldown: 1500, hitFlashTime: 200, drop: { type: 'seed', count: 2 } },
        };
        const MAX_ACTIVE_MONSTERS = 5; // M√°ximo de monstruos activos en el mapa
        const MONSTER_SPAWN_INTERVAL_MS = 15000; // Intervalo de aparici√≥n de monstruos en ms
        let lastMonsterSpawnTime = 0; // √öltima vez que apareci√≥ un monstruo
        let monsters = []; // Initialize monsters array
        const damagePopups = []; // Array to store active damage numbers

        // Pool de todos los materiales din√°micos posibles (excluyendo tierra y agua que son fuentes)
        const materialPool = [
            'eggshells', 'bananaPeels', 'orangePeels', 'foodScraps', 'cebolla', 'carrotSeed', 'tomatoSeed',
            'seed_hierbabuena', 'seed_oregano', 'seed_romero', 'seed_albahaca', 'seed_cilantro', 'seed_cilantroCimarron'
        ];

        // Materiales din√°micos actualmente en el mapa
        let currentMaterials = [];

        // Objeto para el se√±alizador del rat√≥n
        const crosshair = {
            x: 0, // Posici√≥n X del tile del mundo
            y: 0, // Posici√≥n Y del tile del mundo
            visible: false
        };

        // Elementos de la interfaz de usuario
        const compostCountSpan = document.getElementById('compost-count');
        const compostMaxSpan = document.getElementById('compost-max');
        const compostStateSpan = document.getElementById('compost-state');
        const messageBox = document.getElementById('messageBox');
        const dayCounterSpan = document.getElementById('day-counter');
        const totalDaysSpan = document.getElementById('total-days'); // Nuevo span para el total de d√≠as
        const dayTimerSpan = document.getElementById('day-timer');
        const phaseIndicatorSpan = document.getElementById('phase-indicator');
        const healthValueSpan = document.getElementById('health-value');
        const healthBar = document.getElementById('health-bar');
        
        const questionOverlay = document.getElementById('questionOverlay');
        const questionTextElement = document.getElementById('questionText');
        const optionsContainer = document.getElementById('optionsContainer');
        const questionTimerElement = document.getElementById('questionTimer');

        const dialogueBox = document.getElementById('dialogueBox');
        const dialogueTextElement = document.getElementById('dialogueText');
        const dialogueOptionsElement = document.getElementById('dialogueOptions');
        let dialogueActive = false; // Bandera para saber si el di√°logo est√° activo

        // Elementos de la interfaz de usuario del inventario
        const inventoryOverlay = document.getElementById('inventoryOverlay');
        const fullInventoryHotbarSlotsContainer = document.getElementById('fullInventoryHotbarSlots'); // Para la barra de acceso r√°pido dentro del inventario completo
        const storageSlotsContainer = document.getElementById('storageSlots'); // Para las ranuras de almacenamiento
        const draggedItemVisual = document.getElementById('draggedItemVisual'); // Elemento visual del objeto arrastrado
        let inventoryOpen = false; // Bandera para saber si el inventario est√° abierto
        let draggingItem = null; // Almacena { item: {type, count}, originalSlotIndex } cuando se arrastra un objeto

        // Sistema de tiempo del juego
        let gameDay = 1; // D√≠a actual del juego
        const TOTAL_GAME_DAYS = 28; // 4 semanas * 7 d√≠as/semana
        let gameStartTime = 0; // Hora de inicio del juego (timestamp)
        const dayDurationSeconds = 300; // Duraci√≥n del d√≠a en segundos (5 minutos)
        const nightDurationSeconds = 300; // Duraci√≥n de la noche en segundos (5 minutos)
        const totalCycleDurationSeconds = dayDurationSeconds + nightDurationSeconds; // Duraci√≥n total de un ciclo d√≠a/noche
        let isNight = false; // Bandera para saber si es de noche
        let gameRunning = true; // Bandera para saber si el juego est√° en ejecuci√≥n

        // Sistema de desaf√≠os/preguntas
        let questionActive = false; // Bandera para saber si una pregunta est√° activa
        let currentMaterialToCollect = null; // Material que se intenta recolectar con la pregunta
        let currentQuestionData = null; // Datos de la pregunta actual
        let questionStartTime = 0; // Hora de inicio de la pregunta
        const QUESTION_DURATION_MS = 10000; // Duraci√≥n de la pregunta en ms (10 segundos)
        let selectedOptionIndex = -1; // √çndice de la opci√≥n seleccionada en la pregunta

        // Aparici√≥n/desaparici√≥n de materiales
        const MAX_ACTIVE_MATERIALS = 8; // M√°ximo de materiales activos en el mapa
        const MATERIAL_SPAWN_INTERVAL_MS = 8000; // Intervalo de aparici√≥n de materiales en ms
        const MATERIAL_DESPAWN_TIME_MS = 30000; // Tiempo de desaparici√≥n de materiales en ms
        let lastMaterialSpawnTime = 0; // √öltima vez que apareci√≥ un material

        // Estado de las parcelas de la huerta (ahora en el canvas)
        // Un array de objetos, donde cada objeto representa una parcela plantada.
        const plantedFarmPlots = []; 

        // Inicializaci√≥n del mapa y ubicaciones de √°rboles
        const gameMap = [];
        const treeLocations = [];

        // Llenar el mapa con tiles de c√©sped por defecto
        for (let y = 0; y < MAP_HEIGHT; y++) {
            gameMap[y] = [];
            for (let x = 0; x < MAP_WIDTH; x++) {
                gameMap[y][x] = 8; // Tile de c√©sped
            }
        }

        // Colocar el dise√±o de la casa en el mapa
        for (let y = 0; y < originalHouseLayout.length; y++) {
            for (let x = 0; x < originalHouseLayout[y].length; x++) {
                const newMapX = houseOffsetX + x;
                const newMapY = houseOffsetY + y;
                if (newMapX < MAP_WIDTH && newMapY < MAP_HEIGHT) {
                    gameMap[newMapY][newMapX] = originalHouseLayout[y][x];
                }
            }
        }

        // Definir la puerta de salida al patio
        const patioExitDoorX = houseOffsetX + 24;
        const patioExitDoorY = houseOffsetY + 10;
        if (patioExitDoorX < MAP_WIDTH && patioExitDoorY < MAP_HEIGHT) {
            gameMap[patioExitDoorY][patioExitDoorX] = 7; // Tile de puerta
            if (patioExitDoorX + 1 < MAP_WIDTH) {
                gameMap[patioExitDoorY][patioExitDoorX + 1] = 8; // Asegurar c√©sped al lado de la puerta
            }
        }

        // Funci√≥n para verificar si una coordenada est√° dentro del √°rea de la casa
        const isWithinHouseArea = (x, y) => {
            return (x >= houseOffsetX && x < houseOffsetX + originalHouseLayout[0].length &&
                    y >= houseOffsetY && y < originalHouseLayout.length);
        };

        // Generar r√≠os aleatorios
        for (let y = 0; y < MAP_HEIGHT; y++) {
            if (y % 15 === 0 && y > houseOffsetY + originalHouseLayout.length + 5) {
                let riverStartX = Math.floor(Math.random() * (MAP_WIDTH - 20));
                let riverWidth = Math.floor(Math.random() * 3) + 2;
                for (let x = riverStartX; x < riverStartX + riverWidth; x++) {
                    if (x < MAP_WIDTH && y < MAP_HEIGHT && gameMap[y][x] === 8 && !isWithinHouseArea(x, y)) {
                        gameMap[y][x] = 10; // Tile de r√≠o
                    }
                }
            }
        }

        // Generar √°rboles aleatorios
        for (let i = 0; i < 200; i++) {
            let treeX = Math.floor(Math.random() * MAP_WIDTH);
            let treeY = Math.floor(Math.random() * MAP_HEIGHT);
            // Asegurarse de que el √°rbol no se superponga con la casa, r√≠os o caminos
            if (gameMap[treeY][treeX] === 8 && !isWithinHouseArea(treeX, treeY) && gameMap[treeY][treeX] !== 10 && gameMap[treeY][treeX] !== 11) {
                gameMap[treeY][treeX] = 9; // Tile de √°rbol
                treeLocations.push({x: treeX, y: treeY}); // Guardar ubicaci√≥n del √°rbol
            }
        }

        // Generar caminos
        for (let y = houseOffsetY + originalHouseLayout[0].length - 2; y < MAP_HEIGHT; y++) {
            const pathX = houseOffsetX + originalHouseLayout[0].length - 2;
            if (gameMap[y][pathX] === 8 || gameMap[y][pathX] === 6) {
                gameMap[y][pathX] = 11; // Tile de camino
            }
        }
        for (let x = houseOffsetX + originalHouseLayout[0].length - 2; x < MAP_WIDTH; x++) {
            const pathY = houseOffsetY + originalHouseLayout.length - 2;
            if (gameMap[pathY][x] === 8 || gameMap[pathY][x] === 6) {
                gameMap[pathY][x] = 11; // Tile de camino
            }
        }
        for (let i = 0; i < 40; i++) {
            let pathStartX = Math.floor(Math.random() * MAP_WIDTH);
            let pathStartY = Math.floor(Math.random() * MAP_HEIGHT);
            let pathLength = Math.floor(Math.random() * 20) + 10;
            let direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';

            for (let j = 0; j < pathLength; j++) {
                let currentX = pathStartX;
                let currentY = pathStartY;
                if (direction === 'horizontal') {
                    currentX = (pathStartX + j);
                } else {
                    currentY = (pathStartY + j);
                }

                if (currentX >= 0 && currentX < MAP_WIDTH && currentY >= 0 && currentY < MAP_HEIGHT) {
                    const tileType = gameMap[currentY][currentX];
                    // Asegurarse de que el camino no se superponga con la casa, √°rboles o r√≠os
                    if ((tileType === 8 || tileType === 6) && !isWithinHouseArea(currentX, currentY) && tileType !== 9 && tileType !== 10) {
                        gameMap[currentY][currentX] = 11; // Tile de camino
                    }
                }
            }
        }

        // Funci√≥n para colocar lagos
        const placeLake = (size, count) => {
            const lakeTileType = size === 'small' ? 12 : 13; // Tipo de tile de lago (peque√±o o grande)
            const minDim = size === 'small' ? 3 : 8; // Dimensi√≥n m√≠nima del lago
            const maxDim = size === 'small' ? 5 : 15; // Dimensi√≥n m√°xima del lago

            for (let i = 0; i < count; i++) {
                let lakeWidth = Math.floor(Math.random() * (maxDim - minDim + 1)) + minDim;
                let lakeHeight = Math.floor(Math.random() * (maxDim - minDim + 1)) + minDim;
                let lakeX = Math.floor(Math.random() * (MAP_WIDTH - lakeWidth));
                let lakeY = Math.floor(Math.random() * (MAP_HEIGHT - lakeHeight));

                let canPlace = true;
                // Verificar si se puede colocar el lago sin superponerse con otros elementos
                for (let y = lakeY; y < lakeY + lakeHeight; y++) {
                    for (let x = lakeX; x < lakeX + lakeWidth; x++) {
                        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT || isWithinHouseArea(x, y) || gameMap[y][x] === 9 || gameMap[y][x] === 10 || gameMap[y][x] === 11) {
                            canPlace = false;
                            break;
                        }
                    }
                    if (!canPlace) break;
                }

                // Si se puede colocar, dibujar el lago
                if (canPlace) {
                    for (let y = lakeY; y < lakeY + lakeHeight; y++) {
                        for (let x = lakeX; x < lakeX + lakeWidth; x++) {
                            gameMap[y][x] = lakeTileType;
                        }
                    }
                }
            }
        };

        placeLake('small', 5); // Colocar 5 lagos peque√±os
        placeLake('large', 2); // Colocar 2 lagos grandes

        // Colores para las flores
        const flowerColors = ['#FFC107', '#E91E63', '#9C27B0', '#2196F3'];
        // Generar arbustos y flores aleatoriamente en el c√©sped
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                if (gameMap[y][x] === 8) { // Si es un tile de c√©sped
                    if (Math.random() < 0.05) {
                        gameMap[y][x] = 14; // Arbusto
                    } else if (Math.random() < 0.03) {
                        gameMap[y][x] = 15; // Flor
                    }
                }
            }
        }
        // Ajustar algunas flores para que aparezcan cerca de los arbustos
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                if (gameMap[y][x] === 14) { // Si es un arbusto
                    if (Math.random() < 0.1) {
                        gameMap[y][x] = 15; // Cambiar a flor (para que haya m√°s variedad)
                    }
                }
            }
        }

        // Nuevas semillas de hierbas disponibles para que los monstruos las suelten
        const herbSeedTypes = [
            'seed_hierbabuena', 'seed_oregano', 'seed_romero', 'seed_albahaca', 'seed_cilantro', 'seed_cilantroCimarron'
        ];

        // Probabilidades para el drop de semillas de hierbas
        const herbSeedProbabilities = {
            'seed_hierbabuena': 0.20,
            'seed_oregano': 0.15,
            'seed_romero': 0.10,
            'seed_albahaca': 0.20,
            'seed_cilantro': 0.25,
            'seed_cilantroCimarron': 0.10
        };

        /**
         * Carga una imagen y actualiza el progreso de carga.
         * @param {string} name - El nombre bajo el cual se almacenar√° la imagen en loadedImages.
         * @param {string} src - La URL de la imagen.
         */
        function loadImage(name, src) {
            const img = new Image(); // Crear un nuevo objeto Image
            img.src = src; // Establecer la fuente de la imagen
            img.onload = () => {
                loadedImages[name] = img; // Almacenar la imagen cargada
                imageLoadedSuccessfully[name] = true; // Marcar como cargada exitosamente
                assetsLoaded++; // Incrementar el contador de activos cargados
                loadingProgressSpan.textContent = `${assetsLoaded}/${assetsToLoad}`; // Actualizar el progreso en la UI
                console.log(`[LOAD] Loaded: ${name} (${assetsLoaded}/${assetsToLoad})`);
                checkAllAssetsLoaded(); // Verificar si todos los activos han cargado
            };
            img.onerror = () => {
                console.error(`[LOAD ERROR] Failed to load: ${src}. Using fallback. (${assetsLoaded}/${assetsToLoad})`);
                loadedImages[name] = null; // Establecer como nulo si hay error
                imageLoadedSuccessfully[name] = false; // Marcar como fallo de carga
                assetsLoaded++; // Incrementar el contador de activos cargados (incluso con error)
                loadingProgressSpan.textContent = `${assetsLoaded}/${assetsToLoad}`; // Actualizar el progreso en la UI
                checkAllAssetsLoaded(); // Verificar si todos los activos han cargado
            };
        }

        /**
         * Verifica si todos los activos (im√°genes) han sido cargados y pre-renderiza el mapa e inicializa el juego si es as√≠.
         */
        function checkAllAssetsLoaded() {
            console.log(`[CHECK] Assets loaded: ${assetsLoaded}, Assets to load: ${assetsToLoad}, Game initialized: ${gameInitialized}`);
            if (assetsLoaded === assetsToLoad && !gameInitialized) {
                console.log("Todos los activos (im√°genes) cargados. Pre-renderizando mapa est√°tico e iniciando juego.");
                try { 
                    drawStaticMap(); // Dibuja el mapa est√°tico una vez
                    gameInitialized = true; // Marcar el juego como inicializado
                    loadingOverlay.style.display = 'none'; // Ocultar la pantalla de carga
                    console.log("Loading overlay hidden."); // Confirm overlay is hidden
                    gameStartTime = performance.now(); // Establecer la hora de inicio del juego
                    player.lastHealthRegenTime = performance.now(); // Inicializar el tiempo de regeneraci√≥n de salud
                    lastMaterialSpawnTime = performance.now(); // Inicializar el tiempo de aparici√≥n de materiales
                    lastMonsterSpawnTime = performance.now(); // Inicializar el tiempo de aparici√≥n de monstruos
                    respawnMaterials(); // Hacer aparecer los materiales iniciales
                    addInitialItemsToInventory(); // A√±adir la espada y otros items iniciales
                    totalDaysSpan.textContent = TOTAL_GAME_DAYS; // Actualizar el total de d√≠as en la UI
                    showMessage('¬°Bienvenido al Juego de Compost Casero! Tienes 4 semanas para crear compost perfecto. ¬°Cada d√≠a dura 5 minutos!', 4000);
                    requestAnimationFrame(gameLoop); // Iniciar el bucle del juego
                } catch (error) {
                    console.error("Error durante la inicializaci√≥n del juego:", error);
                    showMessage("Error al iniciar el juego. Por favor, revisa la consola para m√°s detalles.", 5000);
                }
            }
        }

        // --- Iniciar la carga de im√°genes ---
        imageUrlsToLoad.forEach(url => {
            // Extraer el nombre de la imagen para usarlo como clave en loadedImages
            const name = url.substring(url.lastIndexOf('/') + 1, url.lastIndexOf('.'));
            loadImage(name, url);
        });
        // -----------------------------------


        let messageTimeout; // Temporizador para ocultar el mensaje
        /**
         * Muestra un mensaje en la caja de mensajes durante una duraci√≥n determinada.
         * @param {string} msg - El mensaje a mostrar.
         * @param {number} duration - La duraci√≥n en milisegundos para mostrar el mensaje.
         */
        const showMessage = (msg, duration) => {
            clearTimeout(messageTimeout); // Limpiar cualquier temporizador anterior
            messageBox.textContent = msg; // Establecer el texto del mensaje
            messageBox.style.display = 'block'; // Mostrar la caja de mensajes
            messageTimeout = setTimeout(() => {
                messageBox.style.display = 'none'; // Ocultar la caja de mensajes despu√©s de la duraci√≥n
            }, duration);
        };

        /**
         * A√±ade un objeto al inventario del jugador, manejando el apilamiento.
         * @param {string} type - El tipo de objeto (ej., 'soil', 'sword').
         * @param {number} count - La cantidad de objetos a a√±adir.
         */
        const addItemToInventory = (type, count = 1) => {
            const itemDef = materials[type]; // Obtener la definici√≥n del material o semilla
            if (!itemDef) {
                console.error(`Se intent√≥ a√±adir un tipo de objeto desconocido: ${type}`);
                return;
            }

            if (itemDef.stackable) {
                // Intentar apilar en ranuras existentes
                for (let i = 0; i < player.inventory.length; i++) {
                    const slot = player.inventory[i];
                    if (slot && slot.type === type && slot.count < itemDef.maxStack) {
                        const spaceLeft = itemDef.maxStack - slot.count;
                        const amountToAdd = Math.min(count, spaceLeft);
                        slot.count += amountToAdd;
                        count -= amountToAdd;
                        if (count === 0) {
                            updateInventoryUI(inventoryOpen); // Actualizar UI si se a√±ade algo
                            return; // Todo el objeto fue a√±adido
                        }
                    }
                }
            }

            // A√±adir a ranuras vac√≠as
            while (count > 0) {
                let added = false;
                for (let i = 0; i < player.inventory.length; i++) {
                    if (!player.inventory[i]) {
                        const amountToAdd = itemDef.stackable ? Math.min(count, itemDef.maxStack) : 1;
                        player.inventory[i] = { type: type, count: amountToAdd };
                        count -= amountToAdd;
                        added = true;
                        break;
                    }
                }
                if (!added) {
                    showMessage('Inventario lleno. No se pudo a√±adir el objeto.', 1500);
                    break; // No hay m√°s espacio en el inventario
                }
            }
            updateInventoryUI(inventoryOpen); // Actualizar UI si se a√±ade algo
        };

        /**
         * Elimina un objeto de una ranura espec√≠fica del inventario.
         * @param {number} slotIndex - El √≠ndice de la ranura de la que se eliminar√°.
         * @param {number} count - La cantidad de objetos a eliminar.
         * @returns {boolean} Verdadero si los objetos fueron eliminados, falso en caso contrario.
         */
        const removeItemFromInventory = (slotIndex, count = 1) => {
            const slot = player.inventory[slotIndex];
            if (slot && slot.count >= count) {
                slot.count -= count;
                if (slot.count === 0) {
                    player.inventory[slotIndex] = null; // Eliminar el objeto si la cuenta llega a cero
                }
                updateInventoryUI(inventoryOpen); // Actualizar UI si se elimina algo
                return true;
            }
            return false;
        };

        /**
         * A√±ade objetos iniciales al inventario del jugador (ej., espada).
         */
        const addInitialItemsToInventory = () => {
            addItemToInventory('sword', 1);
            addItemToInventory('shovel', 1);
            addItemToInventory('wateringCan', 1);
            addItemToInventory('soil', 5);
            addItemToInventory('bananaPeels', 3);
            addItemToInventory('seed_hierbabuena', 2);
            addItemToInventory('seed_cilantro', 1);
        };

        /**
         * Genera un material aleatorio del pool en un tile transitable aleatorio.
         */
        const spawnRandomMaterial = () => {
            // Filtrar tipos de materiales disponibles que no est√©n ya en el mapa
            const availableMaterialTypes = materialPool.filter(type => {
                return !currentMaterials.some(m => m.type === type && !m.collected);
            });

            if (availableMaterialTypes.length === 0) {
                return; // No hay materiales disponibles para generar
            }

            // Limitar la cantidad de materiales activos en el mapa
            if (currentMaterials.filter(m => !m.collected && materialPool.includes(m.type)).length >= MAX_ACTIVE_MATERIALS) {
                return;
            }

            const randomMaterialType = availableMaterialTypes[Math.floor(Math.random() * availableMaterialTypes.length)];
            let randomX, randomY;
            let foundValidSpot = false;

            let attempts = 0;
            const MAX_ATTEMPTS = 200; // M√°ximo de intentos para encontrar un lugar v√°lido

            // Intentar encontrar un lugar v√°lido fuera de la casa primero
            while (!foundValidSpot && attempts < MAX_ATTEMPTS) {
                randomX = Math.floor(Math.random() * MAP_WIDTH);
                randomY = Math.floor(Math.random() * MAP_HEIGHT);

                const tileType = gameMap[randomY][randomX];
                // Verificar si el tile es transitable y adecuado para materiales
                const isWalkableForMaterialSpawn = (tileType === 8 || tileType === 11 || tileType === 14 || tileType === 15);

                // Verificar si el lugar est√° ocupado por el jugador, compost, fuente, otro material, monstruo, o es un obst√°culo
                const isOccupiedByPlayer = Math.round(player.x) === randomX && Math.round(player.y) === randomY;
                const isOccupiedByCompost = compostPile.x === randomX && compostPile.y === randomY;
                const isOccupiedBySource = tileType === 4 || tileType === 5;
                const isOccupiedByOtherMaterial = currentMaterials.some(m => m.x === randomX && m.y === randomY && !m.collected);
                const isOccupiedByMonster = monsters.some(m => Math.round(m.x) === randomX && Math.round(m.y) === randomY);
                const isObstacle = (tileType === 1 || tileType === 3 || tileType === 9 || tileType === 10 || tileType === 12 || tileType === 13 || tileType === 16 || tileType === 17 || tileType === 18 || tileType === 19);

                // Asegurarse de que est√© fuera del √°rea de la casa
                const isOutsideHouse = !(randomX >= houseOffsetX && randomX < houseOffsetX + originalHouseLayout[0].length &&
                                         randomY >= houseOffsetY && randomY < originalHouseLayout.length);

                if (isWalkableForMaterialSpawn && !isOccupiedByPlayer && !isOccupiedByCompost && !isOccupiedBySource && !isOccupiedByOtherMaterial && !isOccupiedByMonster && !isObstacle && isOutsideHouse) {
                    foundValidSpot = true;
                }
                attempts++;
            }

            // Si no se encontr√≥ un lugar fuera, intentar encontrarlo en cualquier lugar transitable adecuado
            if (!foundValidSpot) {
                attempts = 0;
                while (!foundValidSpot && attempts < MAX_ATTEMPTS) {
                    randomX = Math.floor(Math.random() * MAP_WIDTH);
                    randomY = Math.floor(Math.random() * MAP_HEIGHT);

                    const tileType = gameMap[randomY][randomX];
                    const isWalkableForMaterialSpawn = (tileType === 0 || tileType === 6 || tileType === 8 || tileType === 11 || tileType === 14 || tileType === 15);
                    const isOccupiedByPlayer = Math.round(player.x) === randomX && Math.round(player.y) === randomY;
                    const isOccupiedByCompost = compostPile.x === randomX && compostPile.y === randomY;
                    const isOccupiedBySource = tileType === 4 || tileType === 5;
                    const isOccupiedByOtherMaterial = currentMaterials.some(m => m.x === randomX && m.y === randomY && !m.collected);
                    const isOccupiedByMonster = monsters.some(m => Math.round(m.x) === randomX && Math.round(m.y) === randomY);
                    const isObstacle = (tileType === 9 || tileType === 10 || tileType === 12 || tileType === 13 || tileType === 16 || tileType === 17 || tileType === 18 || tileType === 19);

                    if (isWalkableForMaterialSpawn && !isOccupiedByPlayer && !isOccupiedByCompost && !isOccupiedBySource && !isOccupiedByOtherMaterial && !isOccupiedByMonster && !isObstacle) {
                        foundValidSpot = true;
                    }
                    attempts++;
                }
            }

            // Si se encontr√≥ un lugar v√°lido, a√±adir el material a la lista de materiales actuales
            if (foundValidSpot) {
                currentMaterials.push({
                    type: randomMaterialType,
                    x: randomX,
                    y: randomY,
                    collected: false, // Marcar como no recolectado
                    questionIndex: 0, // √çndice de la pregunta para desaf√≠os
                    spawnTime: performance.now() // Registrar el tiempo de aparici√≥n
                });
            }
        };

        /**
         * Regenera todos los materiales din√°micos recolectados en sus posiciones iniciales.
         */
        const respawnMaterials = () => {
            currentMaterials = []; // Limpiar todos los materiales actuales
            for (let i = 0; i < MAX_ACTIVE_MATERIALS; i++) {
                spawnRandomMaterial(); // Generar nuevos materiales
            }
            // showMessage('¬°Nuevos materiales org√°nicos han aparecido!', 2000); // Comentar para evitar spam
        };

        /**
         * Genera un monstruo aleatorio en un tile transitable fuera de la casa.
         */
        const spawnRandomMonster = () => {
            if (monsters.length >= MAX_ACTIVE_MONSTERS) {
                console.log("M√°ximo de monstruos alcanzado, no se generar√°n m√°s.");
                return; // Limitar la cantidad de monstruos
            }

            const monsterTypesArray = Object.keys(monsterTypes); // Obtener los tipos de monstruos disponibles
            const randomMonsterType = monsterTypesArray[Math.floor(Math.random() * monsterTypesArray.length)]; // Seleccionar un tipo aleatorio
            const monsterDef = monsterTypes[randomMonsterType]; // Obtener la definici√≥n del monstruo

            let randomX, randomY;
            let foundValidSpot = false;
            let attempts = 0;
            const MAX_ATTEMPTS = 200; // M√°ximo de intentos para encontrar un lugar

            // Intentar encontrar un lugar v√°lido fuera de la casa
            while (!foundValidSpot && attempts < MAX_ATTEMPTS) {
                randomX = Math.floor(Math.random() * MAP_WIDTH);
                randomY = Math.floor(Math.random() * MAP_HEIGHT);

                const tileType = gameMap[randomY][randomX];
                // Los monstruos deben aparecer en c√©sped (8), camino (11) o patio (6) y fuera de la casa
                const isWalkableForMonsterSpawn = (tileType === 8 || tileType === 11 || tileType === 6);

                // Verificar si el lugar est√° ocupado por el jugador, compost, fuente, material, NPC u otro monstruo
                const isOccupiedByPlayer = Math.round(player.x) === randomX && Math.round(player.y) === randomY;
                const isOccupiedByCompost = compostPile.x === randomX && compostPile.y === randomY;
                const isOccupiedBySource = tileType === 4 || tileType === 5;
                const isOccupiedByMaterial = currentMaterials.some(m => m.x === randomX && m.y === randomY && !m.collected);
                const isOccupiedByNPC = (randomX === elara.x && randomY === elara.y) ||
                                         (randomX === silasVane.x && silasVane.y) ||
                                         (randomX === compostGuru.x && randomY === compostGuru.y); // Check for new NPC
                const isOccupiedByOtherMonster = monsters.some(m => Math.round(m.x) === randomX && Math.round(m.y) === randomY);

                // Verificar si es un obst√°culo que bloquea la aparici√≥n (no el jugador/NPC/materiales)
                const isObstacle = (tileType === 1 || tileType === 3 || tileType === 9 || tileType === 10 || tileType === 12 || tileType === 13 || tileType === 16 || tileType === 17 || tileType === 18 || tileType === 19);

                // Asegurarse de que est√© fuera del √°rea de la casa
                const isOutsideHouse = !(randomX >= houseOffsetX && randomX < houseOffsetX + originalHouseLayout[0].length &&
                                         randomY >= houseOffsetY && randomY < originalHouseLayout.length);

                if (isWalkableForMonsterSpawn && !isOccupiedByPlayer && !isOccupiedByCompost && !isOccupiedBySource && !isOccupiedByMaterial && !isOccupiedByNPC && !isOccupiedByOtherMonster && !isObstacle && isOutsideHouse) {
                    foundValidSpot = true;
                }
                attempts++;
            }

            // Si se encontr√≥ un lugar v√°lido, a√±adir el monstruo a la lista
            if (foundValidSpot) {
                monsters.push({
                    type: randomMonsterType,
                    x: randomX,
                    y: randomY,
                    health: monsterDef.health,
                    maxHealth: monsterDef.health,
                    damage: monsterDef.damage,
                    speed: monsterDef.speed,
                    emoji: monsterDef.emoji,
                    color: monsterDef.color,
                    attackCooldown: monsterDef.attackCooldown,
                    lastAttackTime: 0,
                    hitFlashTime: monsterDef.hitFlashTime || 0, // Time monster flashes after being hit
                    lastHitTime: 0, // Last time monster was hit for flash effect
                    drop: monsterDef.drop // El drop ahora es un objeto que contiene tipo y cantidad
                });
                // console.log(`Monstruo ${randomMonsterType} generado en (${randomX}, ${randomY}). Total: ${monsters.length}`); // Comentar para evitar spam
            } else {
                // console.log(`No se pudo encontrar un lugar v√°lido para generar un monstruo despu√©s de ${MAX_ATTEMPTS} intentos.`); // Comentar para evitar spam
            }
        };

        /**
         * Mueve al jugador por un delta dado en coordenadas x e y,
         * comprobando los l√≠mites del mapa y los obst√°culos.
         * @param {number} dx - El cambio en la coordenada x.
         * @param {number} dy - El cambio en la coordenada y.
         */
        const movePlayer = (dx, dy) => {
            // No permitir el movimiento si hay una pregunta, di√°logo o inventario abierto
            if (questionActive || dialogueActive || inventoryOpen) return;

            // Si el jugador ya se est√° moviendo hacia un objetivo, no aceptar nuevas entradas de movimiento
            if (Math.abs(player.x - player.targetX) > 0.01 || Math.abs(player.y - player.targetY) > 0.01) {
                return;
            }

            const newTargetX = Math.round(player.x) + dx; // Calcular la nueva posici√≥n X objetivo
            const newTargetY = Math.round(player.y) + dy; // Calcular la nueva posici√≥n Y objetivo

            // Verificar l√≠mites del mapa
            if (newTargetX >= 0 && newTargetX < MAP_WIDTH &&
                newTargetY >= 0 && newTargetY < MAP_HEIGHT) {
                const targetTileType = gameMap[newTargetY][newTargetX]; // Obtener el tipo de tile del objetivo
                // Verificar si el tile objetivo est√° ocupado por un NPC o monstruo
                const isNpcTile = (newTargetX === elara.x && newTargetY === elara.y) ||
                                  (newTargetX === silasVane.x && silasVane.y) ||
                                  (newTargetX === compostGuru.x && newTargetY === compostGuru.y); // Check for new NPC
                const isMonsterTile = monsters.some(m => Math.round(m.x) === newTargetX && Math.round(m.y) === newTargetY);

                // Verificar si el tile objetivo no es un obst√°culo
                if (targetTileType !== 1 && // Pared
                    targetTileType !== 3 && // Mueble
                    targetTileType !== 9 && // Tronco de √°rbol
                    targetTileType !== 10 && // R√≠o/Agua
                    targetTileType !== 12 && // Lago peque√±o
                    targetTileType !== 13 && // Lago grande
                    targetTileType !== 16 && // Cama (como obst√°culo para el movimiento normal)
                    !isNpcTile && // No es un tile de NPC
                    !isMonsterTile) { // No es un tile de monstruo
                    player.targetX = newTargetX; // Establecer nueva posici√≥n X objetivo
                    player.targetY = newTargetY; // Establecer nueva posici√≥n Y objetivo

                    // Actualizar la direcci√≥n del jugador para la animaci√≥n
                    if (dx < 0) {
                        player.direction = 'left';
                    } else if (dx > 0) {
                        player.direction = 'right';
                    }
                }
            }
        };

        /**
         * Interpola suavemente al jugador hacia sus coordenadas objetivo.
         * @param {number} deltaTime - Tiempo transcurrido desde el √∫ltimo fotograma en milisegundos.
         */
        const handlePlayerMovement = (deltaTime) => {
            if (player.x !== player.targetX || player.y !== player.targetY) {
                const distanceX = player.targetX - player.x; // Distancia en X
                const distanceY = player.targetY - player.y; // Distancia en Y
                const currentDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY); // Distancia total
                const moveDistance = player.speed * deltaTime; // Distancia a moverse en este frame

                if (currentDistance <= moveDistance) {
                    player.x = player.targetX; // Lleg√≥ al objetivo
                    player.y = player.targetY; // Lleg√≥ al objetivo
                } else {
                    // Mover suavemente hacia el objetivo
                    player.x += (distanceX / currentDistance) * moveDistance;
                    player.y += (distanceY / currentDistance) * moveDistance;
                }
            }
        };

        /**
         * Muestra una superposici√≥n de pregunta de opci√≥n m√∫ltiple.
         * @param {object} question - El objeto de pregunta a mostrar.
         */
        const displayQuestion = (question) => {
            questionOverlay.style.display = 'flex'; // Mostrar la superposici√≥n de preguntas
            questionTextElement.textContent = question.text; // Establecer el texto de la pregunta
            optionsContainer.innerHTML = ''; // Limpiar opciones anteriores

            // Crear botones para cada opci√≥n de la pregunta
            question.options.forEach((optionText, index) => {
                const button = document.createElement('button');
                button.classList.add('option-button');
                button.textContent = `${optionText}`;
                button.dataset.optionIndex = index;
                button.addEventListener('click', () => {
                    selectOption(index); // Manejar la selecci√≥n de la opci√≥n
                });
                optionsContainer.appendChild(button);
            });
            selectedOptionIndex = -1; // Restablecer la opci√≥n seleccionada
        };

        /**
         * Maneja la selecci√≥n de opciones para la superposici√≥n de preguntas.
         * @param {number} index - El √≠ndice de la opci√≥n seleccionada.
         */
        const selectOption = (index) => {
            if (questionActive) {
                selectedOptionIndex = index; // Establecer la opci√≥n seleccionada
                // Actualizar clases CSS para resaltar la opci√≥n seleccionada
                Array.from(optionsContainer.children).forEach((btn, i) => {
                    if (i === index) {
                        btn.classList.add('selected');
                    } else {
                        btn.classList.remove('selected');
                    }
                });
            }
        };

        /**
         * Resuelve la pregunta actual bas√°ndose en la selecci√≥n del jugador o el tiempo de espera.
         */
        const resolveQuestion = () => {
            questionOverlay.style.display = 'none'; // Ocultar la superposici√≥n de preguntas
            questionActive = false; // Desactivar la bandera de pregunta activa
            questionTimerElement.textContent = ''; // Limpiar el temporizador

            const materialType = currentMaterialToCollect.type; // Tipo de material de la pregunta
            const questionSet = materials[materialType].questions; // Conjunto de preguntas para ese material
            const currentQ = questionSet[currentMaterialToCollect.questionIndex]; // Pregunta actual

            let correct = false;
            if (selectedOptionIndex !== -1) {
                correct = (selectedOptionIndex === currentQ.correctOptionIndex); // Comprobar si la respuesta es correcta
            } else {
                correct = false; // Si no se seleccion√≥ ninguna opci√≥n, es incorrecta
            }

            if (correct) {
                addItemToInventory(currentMaterialToCollect.type, 1); // A√±adir el material al inventario
                currentMaterialToCollect.collected = true; // Marcar el material como recolectado
                showMessage(`¬°Respuesta correcta! Recogiste ${materials[currentMaterialToCollect.type].displayName}.`, 1500);
            } else {
                showMessage('¬°Respuesta incorrecta o se acab√≥ el tiempo! Int√©ntalo de nuevo.', 1500);
                // Pasar a la siguiente pregunta si la respuesta fue incorrecta
                currentMaterialToCollect.questionIndex = (currentMaterialToCollect.questionIndex + 1) % questionSet.length;
            }

            currentMaterialToCollect = null; // Limpiar el material a recolectar
            currentQuestionData = null; // Limpiar los datos de la pregunta
            selectedOptionIndex = -1; // Restablecer la opci√≥n seleccionada
        };

        // --- Definiciones de NPCs ---
        const elara = {
            x: houseOffsetX + 20,
            y: houseOffsetY + 25,
            name: "Elara",
            emoji: "üëµ",
            color: "#8B4513",
            currentDialogueIndex: 0,
            dialoguePhase: 'INTRO',
            dialogues: {
                INTRO: [
                    "Elara: '¬øOtro vagabundo perdido en la penumbra? Pocos se aventuran tan lejos de las c√∫pulas. ¬øQu√© te trae a este rinc√≥n olvidado?'",
                    "Elara: 'La Plaga Gris... lo ha consumido casi todo. Pero a√∫n hay esperanza, ¬øsabes? Aqu√≠, en nuestro peque√±o rinc√≥n, intentamos lo imposible: hacer que la vida florezca de nuevo. Pero la tierra... est√° muerta. Necesitamos nutrirla, revivirla.'"
                ],
                MISSION_PROMPT: [
                    "Elara: 'He estado experimentando con un m√©todo antiguo, una t√©cnica de la 'Vieja Tierra' que llamaban 'compostaje'. Es la clave para restaurar la vitalidad de esta tierra moribunda. Necesito tu ayuda, joven. La Corporaci√≥n Zenith no se detendr√° ante nada para detenernos, y mi tiempo es limitado.'",
                    "Elara: '¬øAceptar√°s la misi√≥n de ayudarme a crear compost nutritivo para nuestro jard√≠n y plantar las √∫ltimas semillas de Fruta Solar? El futuro de la vida depende de ello.'"
                ],
                MISSION_ACCEPTED: [
                    "Elara: '¬°Gracias, joven! Tu coraje es un faro en estos tiempos oscuros. Ahora, manos a la obra. Necesitamos compost para revivir esta tierra. ¬°Y no olvides plantar las semillas en el jard√≠n cuando el compost est√© listo!'",
                    "Elara: 'Sigue trabajando en el compost, joven. Cada ciclo nos acerca a restaurar la vida. ¬°Y no olvides plantar las semillas en el jard√≠n cuando el compost est√© listo!'"
                ],
                MISSION_REJECTED: [
                    "Elara: 'Lo entiendo. Es un camino dif√≠cil y peligroso. Pero la esperanza nunca muere, joven. Si cambias de opini√≥n, aqu√≠ estar√©.'",
                    "Elara: 'La misi√≥n sigue en pie si decides unirte a la Resistencia Verde.'"
                ]
            },
            missionAccepted: false,
        };

        const silasVane = {
            x: 100,
            y: 50,
            name: "Silas Vane",
            emoji: "ü¶π‚Äç‚ôÇÔ∏è",
            color: "#333333",
            currentDialogueIndex: 0,
            dialogues: [
                "Silas Vane: 'As√≠ que eres el 'jardinero' del que he o√≠do hablar. Interesante. Mis sensores han detectado un aumento inusual de biomasa en esta √°rea. Y me informan que eres el responsable.'",
                "Silas Vane: 'Tengo una propuesta para ti, 'jardinero'. Esas 'plantas' tuyas... son valiosas. Extremadamente valiosas. La Corporaci√≥n Zenith tiene el monopolio de los recursos restantes. No permitiremos que nadie perturbe ese equilibrio. No hay lugar para la vida salvaje en mi nuevo mundo.'",
                "Silas Vane: 'Dame esas plantas. Todas ellas. No es una petici√≥n. Es una oferta que no puedes rechazar. A cambio, quiz√°s te permita un lugar insignificante en mi imperio. O ser√°s reducido a polvo, como todo lo dem√°s que se interpondr√° en mi camino.'",
                "Silas Vane: 'No te atrevas a desafiar a la Corporaci√≥n Zenith, 'jardinero'. Mis drones est√°n vigilando cada uno de tus movimientos.'"
            ],
        };

        // NEW NPC: Maestro Compostador
        const compostGuru = {
            x: houseOffsetX + 18, // Inside the house
            y: houseOffsetY + 2, // Near the compost bin
            name: "Maestro Compostador",
            emoji: "üë®‚Äçüåæ",
            color: "#6B8E23",
            currentDialogueIndex: 0,
            dialogues: [
                "Maestro Compostador: '¬°Saludos, joven! Veo que tienes inter√©s en la pila de compost. Es el coraz√≥n de nuestra supervivencia aqu√≠.'",
                "Maestro Compostador: 'Para hacer compost, necesitas tres cosas principales: materiales 'marrones' (como tierra o ramas secas), materiales 'verdes' (como c√°scaras de fruta, restos de comida), y agua.'",
                "Maestro Compostador: 'Empieza a√±adiendo tierra, luego un material org√°nico. Despu√©s, riega la pila con tu regadera. Una vez que est√© h√∫meda, revu√©lvela con tu espada. ¬°Y el ciclo se repite!'",
                "Maestro Compostador: 'Cada ciclo de compostaje te acerca a tener tierra f√©rtil. ¬°No te rindas!'"
            ],
        };

        // A√±adir una peque√±a parcela de tierra para el jard√≠n de Elara cerca de ella
        const elaraGardenX = elara.x + 2;
        const elaraGardenY = elara.y;
        const gardenWidth = 5;
        const gardenHeight = 3;
        for (let y = elaraGardenY; y < elaraGardenY + gardenHeight; y++) {
            for (let x = elaraGardenX; x < elaraGardenX + gardenWidth; x++) {
                if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                    gameMap[y][x] = 17; // Nuevo tipo de tile para 'huerta' (tierra de jard√≠n)
                }
            }
        }

        /**
         * Helper function to advance NPC dialogue or hide dialogue box.
         * @param {object} npc - The NPC object.
         * @param {boolean} [showMissionOptions=false] - Whether to show mission options.
         */
        const advanceDialogue = (npc, showMissionOptions = false) => {
            const currentDialogueArray = npc.dialogues[npc.dialoguePhase] || npc.dialogues; // Handle both types
            npc.currentDialogueIndex++;
            if (npc.currentDialogueIndex < currentDialogueArray.length) {
                displayDialogue(npc, currentDialogueArray[npc.currentDialogueIndex], showMissionOptions);
            } else {
                hideDialogue();
                npc.currentDialogueIndex = currentDialogueArray.length - 1; // Stay at last dialogue
                if (npc === elara && elara.dialoguePhase === 'INTRO') { // Special transition for Elara's mission
                    elara.dialoguePhase = 'MISSION_PROMPT';
                    elara.currentDialogueIndex = 0;
                    displayDialogue(elara, elara.dialogues.MISSION_PROMPT[elara.currentDialogueIndex], true);
                }
            }
        };

        /**
         * Muestra un di√°logo en la caja de di√°logo.
         * @param {object} npc - El objeto NPC que est√° hablando actualmente.
         * @param {string} text - El texto a mostrar.
         * @param {boolean} showOptions - Si se deben mostrar las opciones de misi√≥n.
         */
        const displayDialogue = (npc, text, showOptions = false) => {
            dialogueBox.style.display = 'flex'; // Mostrar la caja de di√°logo
            dialogueTextElement.textContent = `${npc.name}: '${text}'`; // Establecer el texto del di√°logo
            dialogueOptionsElement.innerHTML = ''; // Limpiar opciones anteriores
            dialogueActive = true; // Activar la bandera de di√°logo

            if (showOptions && npc === elara && elara.dialoguePhase === 'MISSION_PROMPT') {
                // Crear bot√≥n para aceptar la misi√≥n
                const acceptButton = document.createElement('button');
                acceptButton.classList.add('dialogue-option-button');
                acceptButton.textContent = 'Aceptar Misi√≥n';
                acceptButton.addEventListener('click', () => { acceptMission(); hideDialogue(); }); 
                dialogueOptionsElement.appendChild(acceptButton);

                // Crear bot√≥n para rechazar la misi√≥n
                const rejectButton = document.createElement('button');
                rejectButton.classList.add('dialogue-option-button');
                rejectButton.textContent = 'Rechazar Misi√≥n';
                rejectButton.addEventListener('click', () => { rejectMission(); hideDialogue(); }); 
                dialogueOptionsElement.appendChild(rejectButton);
            }
        };

        /**
         * Oculta la caja de di√°logo.
         */
        const hideDialogue = () => {
            dialogueBox.style.display = 'none'; // Ocultar la caja de di√°logo
            dialogueActive = false; // Desactivar la bandera de di√°logo
            dialogueOptionsElement.innerHTML = ''; // Limpiar opciones
        };

        /**
         * Maneja la aceptaci√≥n de la misi√≥n de Elara.
         */
        const acceptMission = () => {
            elara.missionAccepted = true; // Marcar la misi√≥n como aceptada
            elara.dialoguePhase = 'MISSION_ACCEPTED'; // Cambiar la fase del di√°logo
            elara.currentDialogueIndex = -1; // Reset index so it starts from 0 on next interaction
            showMessage("¬°Misi√≥n 'Coraz√≥n de la Tierra' aceptada!", 3000); // Mostrar mensaje de confirmaci√≥n
        };

        /**
         * Maneja el rechazo de la misi√≥n de Elara.
         */
        const rejectMission = () => {
            elara.missionAccepted = false; // Marcar la misi√≥n como rechazada
            elara.dialoguePhase = 'MISSION_REJECTED'; // Cambiar la fase del di√°logo
            elara.currentDialogueIndex = -1; // Reset index
            showMessage("Misi√≥n rechazada. Elara parece decepcionada.", 3000); // Mostrar mensaje de confirmaci√≥n
        };

        /**
         * Calcula la distancia entre dos puntos.
         */
        const getDistance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        };

        /**
         * Displays a floating damage number above a given position.
         * @param {number} damage - The amount of damage.
         * @param {number} x - World X coordinate of the hit.
         * @param {number} y - World Y coordinate of the hit.
         */
        const showDamageNumber = (damage, x, y) => {
            const popup = {
                value: damage,
                x: x * TILE_SIZE,
                y: y * TILE_SIZE,
                startTime: performance.now(),
                element: document.createElement('div')
            };
            popup.element.classList.add('damage-number');
            popup.element.textContent = `-${damage}`;
            gameContainer.appendChild(popup.element); // Append to game container
            damagePopups.push(popup);
        };

        /**
         * Maneja la acci√≥n del jugador (usar objeto, interactuar con compost, atacar).
         * @param {boolean} isClick - Indica si la acci√≥n fue activada por un clic del rat√≥n.
         */
        const handleAction = (isClick = false) => {
            // No permitir la acci√≥n si hay una pregunta, di√°logo o inventario abierto
            if (questionActive || inventoryOpen) return;

            const playerTileX = Math.round(player.x); // Posici√≥n X del tile del jugador
            const playerTileY = Math.round(player.y); // Posici√≥n Y del tile del jugador
            const activeItem = player.inventory[player.activeSlotIndex]; // Obtener el objeto activo en el inventario
            const activeItemDef = activeItem ? materials[activeItem.type] : null; // Obtener la definici√≥n del objeto activo
            const currentTime = performance.now(); // Obtener el tiempo actual una vez para eficiencia

            // --- Prioridad 0: Manejar avance de di√°logo si est√° activo ---
            if (dialogueActive) {
                // Determine which NPC is currently talking
                if (dialogueTextElement.textContent.startsWith(`${elara.name}:`)) {
                    advanceDialogue(elara);
                } else if (dialogueTextElement.textContent.startsWith(`${silasVane.name}:`)) {
                    advanceDialogue(silasVane);
                } else if (dialogueTextElement.textContent.startsWith(`${compostGuru.name}:`)) { // New NPC dialogue advancement
                    advanceDialogue(compostGuru);
                }
                return; // Dialogue handled, exit function
            }


            // --- Prioridad 1: Si es un click y el objeto activo es un arma, intentar atacar PRIMERO y salir. ---
            if (isClick && activeItemDef && activeItemDef.type === 'weapon') {
                if (currentTime - player.lastAttackTime > player.attackCooldown) {
                    const targetTileX = crosshair.x;
                    const targetTileY = crosshair.y;

                    // Buscar un monstruo en la posici√≥n del crosshair y dentro del rango de ataque del jugador
                    let monsterHit = monsters.find(m =>
                        Math.round(m.x) === targetTileX &&
                        Math.round(m.y) === targetTileY &&
                        getDistance(playerTileX, playerTileY, targetTileX, targetTileY) <= 1.5 // Rango de ataque
                    );

                    if (monsterHit) {
                        // Si se golpea un monstruo, reducir su salud
                        monsterHit.health -= activeItemDef.damage;
                        monsterHit.lastHitTime = currentTime; // For hit flash effect
                        showDamageNumber(activeItemDef.damage, monsterHit.x, monsterHit.y - 0.5); // Show damage
                        player.lastAttackTime = currentTime; // Reiniciar el tiempo del √∫ltimo ataque
                        showMessage(`¬°Atacaste al ${monsterHit.type}! Salud restante: ${Math.max(0, monsterHit.health)}`, 1000);
                        return; // Ataque exitoso, salir.
                    } else {
                        showMessage('¬°El ataque fall√≥! No hay monstruos en el objetivo.', 500);
                        return; // Ataque fallido, pero fue un intento de ataque, salir.
                    }
                } else {
                    showMessage('¬°Esperando para atacar!', 500);
                    return; // En cooldown, fue un intento de ataque, salir.
                }
            }
            // If it's a click and NOT a weapon, or if it's a click and the weapon attack was already handled (failed or successful),
            // the flow from here on only executes if it was NOT a click or if the click was already handled as an attack.
            // Therefore, if `isClick` is true and we reach here, it means it wasn't a weapon. We should not drop the item.
            if (isClick) {
                return; // If it's a click and not a weapon, the click does nothing.
            }

            // --- Prioridad 2: Interactuar con NPCs ---
            const npcs = [elara, silasVane, compostGuru];
            let interactedWithNpc = false;
            for (const npc of npcs) {
                if (Math.abs(playerTileX - npc.x) <= 1 && Math.abs(playerTileY - npc.y) <= 1) {
                    if (!dialogueActive) { // Start new dialogue if not active
                        npc.currentDialogueIndex = -1; // Reset index so advanceDialogue starts at 0
                        advanceDialogue(npc);
                    }
                    interactedWithNpc = true;
                    break;
                }
            }
            if (interactedWithNpc) {
                return;
            }
            
            // --- Prioridad 3: Interactuar con la cama ---
            const nearBed = gameMap[playerTileY] && gameMap[playerTileY][playerTileX] === 16;
            if (nearBed) {
                if (isNight) {
                    gameDay++;
                    dayCounterSpan.textContent = `${gameDay}`;
                    gameStartTime = performance.now(); // Reset time for new day/night cycle
                    isNight = false; // Always start day phase
                    monsters = []; // Limpiar monstruos al amanecer
                    respawnMaterials(); // Regenerar materiales
                    updateFarmPlotGrowth(); // Actualizar el crecimiento de las plantas al inicio del d√≠a
                    showMessage(`¬°Dormiste bien! El d√≠a ${gameDay} ha comenzado.`, 2000);
                    if (gameDay > TOTAL_GAME_DAYS) { // Check for game end after TOTAL_GAME_DAYS
                        gameRunning = false;
                        if (compostPile.count === compostPile.maxCount) {
                            showMessage(`¬°Juego Terminado! ¬°Creaste compost perfecto en ${TOTAL_GAME_DAYS} d√≠as!`, 5000);
                            if (elara.missionAccepted) {
                                showMessage("Elara: '¬°Lo lograste! La tierra vuelve a la vida. ¬°Gracias, campe√≥n!'", 5000);
                            }
                        } else {
                            showMessage(`¬°Juego Terminado! No lograste completar el compost. Compost: ${compostPile.count}/${compostPile.maxCount}`, 5000);
                            if (elara.missionAccepted && compostPile.count < compostPile.maxCount) {
                                showMessage("Elara: 'No logramos restaurar la tierra a tiempo. Pero la esperanza perdura. Quiz√°s otro d√≠a...'", 5000);
                            }
                        }
                    }
                } else {
                    showMessage('Solo puedes dormir de noche.', 1500);
                }
                return;
            }

            // --- Prioridad 4: Interactuar con parcelas de huerta (plantar, regar, cosechar) ---
            const adjacentTiles = [
                { x: playerTileX, y: playerTileY - 1 }, // Up
                { x: playerTileX, y: playerTileY + 1 }, // Down
                { x: playerTileX - 1, y: playerTileY }, // Left
                { x: playerTileX + 1, y: playerTileY }, // Right
            ];

            let interactedWithFarmPlot = false;
            for (const adj of adjacentTiles) {
                if (adj.x >= 0 && adj.x < MAP_WIDTH && adj.y >= 0 && adj.y < MAP_HEIGHT && gameMap[adj.y][adj.x] === 17) {
                    const plot = plantedFarmPlots.find(p => p.x === adj.x && p.y === adj.y);

                    if (!plot) { // Plot is empty, try to plant
                        if (activeItemDef && activeItemDef.type === 'seed' && activeItem && activeItem.count > 0) {
                            // Plant a seed
                            plantedFarmPlots.push({
                                x: adj.x,
                                y: adj.y,
                                plantedSeed: activeItem.type,
                                growthStage: 0,
                                watered: true, // Considered watered for the day it's planted
                                lastWateredDay: gameDay, 
                                lastGrowthDay: gameDay 
                            });
                            removeItemFromInventory(player.activeSlotIndex, 1);
                            showMessage(`¬°Plantaste ${activeItemDef.displayName} en (${adj.x},${adj.y})!`, 1500);
                            interactedWithFarmPlot = true;
                            break; // Action handled, exit loop
                        }
                    } else { // Plot has a plant, try to water or harvest
                        const plantDef = materials[plot.plantedSeed];
                        if (activeItemDef && activeItemDef.displayName === 'Regadera') {
                            if (!plot.watered && plot.lastWateredDay < gameDay) { // Check if not watered today and not watered for this day
                                // Water the plant
                                plot.watered = true;
                                plot.lastWateredDay = gameDay;
                                showMessage(`¬°Regaste ${plantDef.displayName} en (${adj.x},${adj.y})!`, 1500);
                                interactedWithFarmPlot = true;
                                break;
                            } else {
                                showMessage('Esta planta ya ha sido regada hoy o no necesita agua.', 1500);
                                interactedWithFarmPlot = true;
                                break;
                            }
                        } else if (activeItemDef && activeItemDef.displayName === 'Pala' && plot.growthStage >= plantDef.growthTime) {
                            // Harvest the plant
                            addItemToInventory(plantDef.growsTo, 1); // Add harvested plant to inventory
                            plantedFarmPlots.splice(plantedFarmPlots.indexOf(plot), 1); // Remove from planted list
                            showMessage(`¬°Cosechaste ${plantDef.displayName} de (${adj.x},${adj.y})!`, 1500);
                            interactedWithFarmPlot = true;
                            break;
                        } else if (activeItemDef && activeItemDef.displayName === 'Pala' && plot.growthStage < plantDef.growthTime) {
                            showMessage('La planta a√∫n no est√° lista para cosechar.', 1500);
                            interactedWithFarmPlot = true;
                            break;
                        }
                    }
                }
            }

            if (interactedWithFarmPlot) {
                return; // Farm plot interaction handled, stop other actions
            }

            // --- Prioridad 5: Recolectar materiales o recursos naturales (tierra/agua) ---
            const materialNear = currentMaterials.find(mat =>
                !mat.collected &&
                Math.abs(playerTileX - mat.x) <= 1 &&
                Math.abs(playerTileY - mat.y) <= 1
            );
            const onSoilBulk = gameMap[playerTileY] && gameMap[playerTileY][playerTileX] === 5;
            const onWaterSource = gameMap[playerTileY] && gameMap[playerTileY][playerTileX] === 4;

            if (materialNear) {
                if (materials[materialNear.type].challenge) {
                    questionActive = true; // Activate challenge question
                    currentMaterialToCollect = materialNear;
                    currentQuestionData = materials[materialNear.type].questions[materialNear.questionIndex];
                    questionStartTime = performance.now();
                    displayQuestion(currentQuestionData); // Display question
                } else {
                    // For materials without challenge (like soil and water), add directly to inventory
                    addItemToInventory(materialNear.type, 1);
                    materialNear.collected = true; // Mark as collected
                    showMessage(`¬°Recogiste ${materials[materialNear.type].displayName}!`, 1500);
                }
                return;
            } else if (onSoilBulk && (!activeItem || (activeItem.type === 'soil' && activeItem.count < materials.soil.maxStack))) {
                addItemToInventory('soil', 1); // Collect soil
                showMessage(`¬°Recogiste ${materials.soil.displayName}!`, 1500);
                return;
            } else if (onWaterSource && (!activeItem || (activeItem.type === 'water' && activeItem.count < materials.water.maxStack))) {
                addItemToInventory('water', 1); // Collect water
                showMessage(`¬°Recogiste ${materials.water.displayName}!`, 1500);
                return;
            }

            // --- Prioridad 6: Interactuar con la pila de compost ---
            const nearCompost = Math.abs(playerTileX - compostPile.x) <= 1 &&
                                Math.abs(playerTileY - compostPile.y) <= 1;
            if (nearCompost && activeItem) {
                if (compostState === COMPOST_STATES.NEEDS_SOIL && activeItem.type === 'soil') {
                    compostState = COMPOST_STATES.NEEDS_MATERIAL;
                    removeItemFromInventory(player.activeSlotIndex, 1); // Remove soil from inventory
                    showMessage('¬°A√±adiste tierra! Ahora a√±ade un material org√°nico.', 2000);
                } else if (compostState === COMPOST_STATES.NEEDS_MATERIAL && materials[activeItem.type].type === 'green') {
                    compostState = COMPOST_STATES.NEEDS_WATER;
                    removeItemFromInventory(player.activeSlotIndex, 1); // Remove organic material
                    showMessage('¬°A√±adiste material org√°nico! Ahora hidrata el compost.', 2000);
                } else if (compostState === COMPOST_STATES.NEEDS_WATER && activeItem.type === 'water') {
                    compostState = COMPOST_STATES.NEEDS_STIR;
                    removeItemFromInventory(player.activeSlotIndex, 1); // Remove water
                    showMessage('¬°Hidrataste el compost! Ahora revu√©lvelo.', 2000);
                } else if (compostState === COMPOST_STATES.NEEDS_STIR && activeItemDef && activeItemDef.type === 'weapon') { // Use weapon to stir
                    if (compostPile.count < compostPile.maxCount) {
                        compostPile.count++; // Increment compost amount
                        compostState = COMPOST_STATES.NEEDS_SOIL; // Return to start of cycle
                        showMessage('¬°Revolviste el compost! Ciclo completado. ¬°A√±ade m√°s!', 2000);
                        if (compostPile.count === compostPile.maxCount) {
                            compostState = COMPOST_STATES.FULL; // Compost complete
                            showMessage('¬°Compost listo! ¬°Felicidades, hiciste compost perfecto!', 3000);
                        }
                    } else {
                        showMessage('¬°El compost est√° lleno!', 1500);
                    }
                } else if (compostState === COMPOST_STATES.FULL) {
                    showMessage('¬°El compost ya est√° listo!', 1500);
                } else {
                    // Informative messages if trying to add the wrong material
                    if (activeItem && activeItem.type === 'soil' && compostState !== COMPOST_STATES.NEEDS_SOIL) {
                        showMessage('No necesitas tierra ahora mismo para el compost.', 1500);
                    } else if (activeItem && activeItem.type === 'water' && compostState !== COMPOST_STATES.NEEDS_WATER) {
                        showMessage('No necesitas agua ahora mismo para el compost.', 1500);
                    } else if (activeItemDef && materials[activeItem.type].type === 'green' && compostState !== COMPOST_STATES.NEEDS_MATERIAL) {
                        showMessage('No necesitas ese material org√°nico ahora mismo para el compost.', 1500);
                    } else if (activeItemDef && activeItemDef.type === 'weapon' && compostState !== COMPOST_STATES.NEEDS_STIR) {
                        showMessage('Solo necesitas la espada para remover el compost cuando sea necesario.', 1500);
                    } else {
                        showMessage('No puedes hacer eso con el compost ahora mismo.', 1500);
                    }
                }
                return;
            }

            // --- Prioridad 7: Soltar el objeto activo (S√ìLO si la acci√≥n fue con la tecla 'F' o bot√≥n de control) ---
            // Esta secci√≥n solo se ejecuta si `isClick` es falso,
            // ya que si `isClick` es verdadero, la funci√≥n ya habr√≠a retornado en la prioridad 0.
            if (activeItem) {
                const currentTileType = gameMap[playerTileY] && gameMap[playerTileY][playerTileX];
                // Verificar si el tile actual es transitable y no es un obst√°culo/fuente/tile especial
                if (currentTileType !== 1 && currentTileType !== 3 && currentTileType !== 4 && currentTileType !== 5 && currentTileType !== 9 && currentTileType !== 10 && currentTileType !== 12 && currentTileType !== 13 && currentTileType !== 16 && currentTileType !== 17 && currentTileType !== 18 && currentTileType !== 19) {
                    currentMaterials.push({
                        type: activeItem.type,
                        x: playerTileX,
                        y: playerTileY,
                        collected: false,
                        questionIndex: 0,
                        spawnTime: performance.now()
                    });
                    showMessage(`¬°Soltaste ${activeItemDef.displayName}!`, 1500);
                    removeItemFromInventory(player.activeSlotIndex, 1); // Remove one item from inventory
                } else {
                    showMessage('No puedes soltar el material aqu√≠.', 1500);
                }
                return;
            }

            showMessage('Nada que hacer aqu√≠.', 1500); // Default message if no action is performed
        };

        /**
         * Alterna la visibilidad de la superposici√≥n del inventario.
         */
        const toggleInventory = () => {
            inventoryOpen = !inventoryOpen; // Toggle open/closed state
            if (inventoryOpen) {
                inventoryOverlay.style.display = 'flex'; // Show inventory overlay
                // When opening full inventory, ensure hotbar slots inside are also updated
                updateInventoryUI(true);
            } else {
                inventoryOverlay.style.display = 'none'; // Hide inventory overlay
                if (draggingItem) { // If an item was being dragged, drop it when closing inventory
                    const playerTileX = Math.round(player.x);
                    const playerTileY = Math.round(player.y);
                    currentMaterials.push({
                        type: draggingItem.item.type,
                        x: playerTileX,
                        y: playerTileY,
                        collected: false,
                        questionIndex: 0,
                        spawnTime: performance.now()
                    });
                    showMessage(`¬°Soltaste ${materials[draggingItem.item.type].displayName}!`, 1500);
                    draggingItem = null; // Clear dragged item
                    draggedItemVisual.style.display = 'none'; // Hide dragged item visual element
                }
            }
        };

        /**
         * Actualiza la representaci√≥n visual del inventario (solo para la superposici√≥n HTML).
         * @param {boolean} fullInventoryMode - Verdadero si se est√° actualizando la superposici√≥n de inventario completo.
         */
        const updateInventoryUI = (fullInventoryMode = false) => {
            // Update HTML inventory overlay if open
            if (fullInventoryMode) {
                fullInventoryHotbarSlotsContainer.innerHTML = ''; // Clear hotbar slots
                storageSlotsContainer.innerHTML = ''; // Clear storage slots

                // Hotbar slots (0 to 3) in the full inventory
                for (let i = 0; i < 4; i++) {
                    const slotDiv = document.createElement('div');
                    slotDiv.classList.add('inventory-slot');
                    if (player.activeSlotIndex === i) {
                        slotDiv.classList.add('active'); // Highlight active slot
                    }
                    slotDiv.dataset.slotIndex = i;
                    slotDiv.addEventListener('mousedown', handleInventorySlotStartDrag); // Add listener for dragging

                    const item = player.inventory[i];
                    if (item) {
                        const itemDef = materials[item.type];
                        if (itemDef) {
                            slotDiv.innerHTML = `<span class="item-emoji">${itemDef.emoji}</span><span class="item-count">${item.count}</span>`;
                        }
                    }
                    fullInventoryHotbarSlotsContainer.appendChild(slotDiv);
                }

                // Storage slots (4 to 9) in the full inventory
                for (let i = 4; i < 10; i++) {
                    const slotDiv = document.createElement('div');
                    slotDiv.classList.add('inventory-slot');
                    slotDiv.dataset.slotIndex = i;
                    slotDiv.addEventListener('mousedown', handleInventorySlotStartDrag);

                    const item = player.inventory[i];
                    if (item) {
                        const itemDef = materials[item.type];
                        if (itemDef) {
                            slotDiv.innerHTML = `<span class="item-emoji">${itemDef.emoji}</span><span class="item-count">${item.count}</span>`;
                        }
                    }
                    storageSlotsContainer.appendChild(slotDiv);
                }
            }
        };

        /**
         * Handles the mousedown event on an inventory slot to start a drag operation.
         * This function now only applies to the HTML inventory overlay, not the canvas hotbar.
         * @param {Event} event - The mousedown event.
         */
        const handleInventorySlotStartDrag = (event) => {
            event.preventDefault(); // Prevent default browser drag behavior
            const clickedSlotIndex = parseInt(event.currentTarget.dataset.slotIndex); // Get the index of the clicked slot

            if (player.inventory[clickedSlotIndex]) {
                // Start dragging
                draggingItem = {
                    item: { ...player.inventory[clickedSlotIndex] }, // Clone the item to avoid modifying the original directly during drag
                    originalSlotIndex: clickedSlotIndex
                };
                player.inventory[clickedSlotIndex] = null; // Visually remove from original slot
                
                const itemDef = materials[draggingItem.item.type];
                draggedItemVisual.textContent = itemDef.emoji; // Set the emoji of the dragged item
                draggedItemVisual.style.display = 'block'; // Show the dragged item visual element
                updateInventoryUI(inventoryOpen); // Update the UI to show the original slot empty
            }
        };

        /**
         * Handles dropping an item into an inventory slot. This is called by the mouseup listener.
         * @param {number} targetSlotIndex - The index of the slot where the item is dropped.
         */
        const handleInventorySlotDrop = (targetSlotIndex) => {
            if (!draggingItem) return; // Should not happen if called correctly

            const targetSlotItem = player.inventory[targetSlotIndex]; // Get the item in the target slot
            const itemDefToMove = materials[draggingItem.item.type];


            if (targetSlotIndex === draggingItem.originalSlotIndex) {
                // Dropped into the same slot
                player.inventory[targetSlotIndex] = draggingItem.item;
            } else if (targetSlotItem && targetSlotItem.type === draggingItem.item.type && itemDefToMove.stackable && targetSlotItem.count < itemDefToMove.maxStack) {
                // Try to stack
                const spaceLeft = itemDefToMove.maxStack - targetSlotItem.count;
                const amountToMove = Math.min(draggingItem.item.count, spaceLeft);
                targetSlotItem.count += amountToMove;
                draggingItem.item.count -= amountToMove; // Update count of dragged item

                if (draggingItem.item.count > 0) {
                    // If still some left in dragged item, put it back in the original slot
                    player.inventory[draggingItem.originalSlotIndex] = draggingItem.item;
                } else {
                    // All moved, original slot is empty (already null from startDrag)
                }
            } else {
                // Swap items or move to empty slot
                player.inventory[draggingItem.originalSlotIndex] = targetSlotItem; // Put target item (or null) in original slot
                player.inventory[targetSlotIndex] = draggingItem.item; // Put dragged item in target slot
            }

            // Always clear drag state after mouseup
            draggingItem = null;
            draggedItemVisual.style.display = 'none';
            updateInventoryUI(inventoryOpen); // Ensure HTML inventory updates after any drop
        };


        // Input handling
        const keys = {}; // Stores the state of pressed keys
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true; // Mark key as pressed
            if (e.key.toLowerCase() === 'f') {
                if (!e.repeat) { // Prevent repeating action when key is held down
                    handleAction(false); // 'F' key action is not a mouse click
                }
            }
            if (e.key.toLowerCase() === 'e') {
                if (!e.repeat) {
                    toggleInventory(); // Toggle inventory
                }
            }
            // Hotbar selection with number keys
            if (e.key >= '1' && e.key <= '4') { // Only for 4 hotbar slots (0-3)
                player.activeSlotIndex = parseInt(e.key) - 1; // Set active slot
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false; // Mark key as released
        });

        // Mouse click for attack and hotbar selection
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0 && !questionActive && !dialogueActive && !inventoryOpen) { // Left click and no question/dialogue/inventory open
                const rect = canvas.getBoundingClientRect(); // Get canvas size and position
                const mouseX = e.clientX - rect.left; // Mouse X position relative to canvas
                const mouseY = e.clientY - rect.top; // Mouse Y position relative to canvas

                // Check if hotbar was clicked to select slot
                const hotbarStartX = HOTBAR_START_X;
                const hotbarEndX = HOTBAR_START_X + HOTBAR_WIDTH;
                const hotbarStartY = HOTBAR_START_Y;
                const hotbarEndY = HOTBAR_START_Y + HOTBAR_HEIGHT;

                if (mouseX >= hotbarStartX && mouseX <= hotbarEndX &&
                    mouseY >= hotbarStartY && mouseY <= hotbarEndY) {
                    const relativeX = mouseX - HOTBAR_START_X - HOTBAR_PADDING;
                    const clickedSlot = Math.floor(relativeX / (HOTBAR_SLOT_SIZE + HOTBAR_SLOT_SPACING));
                    if (clickedSlot >= 0 && clickedSlot < 4) {
                        player.activeSlotIndex = clickedSlot; // Set active slot
                    }
                    return; // Hotbar click handled
                }

                // If not hotbar, perform main action (attack with crosshair if sword active)
                handleAction(true); // Mouse click action is a mouse click
            }
        });

        // Update mouse crosshair position and dragged item visual
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseCanvasX = e.clientX - rect.left;
            const mouseCanvasY = e.clientY - rect.top;

            // Update crosshair position in world coordinates
            crosshair.x = Math.floor((mouseCanvasX + cameraX) / TILE_SIZE);
            crosshair.y = Math.floor((mouseCanvasY + cameraY) / TILE_SIZE);

            // Determine if crosshair should be visible: only if an weapon is active and no overlays
            const activeItem = player.inventory[player.activeSlotIndex];
            crosshair.visible = (activeItem && materials[activeItem.type].type === 'weapon' && !questionActive && !dialogueActive && !inventoryOpen); // Only visible with weapon

            if (draggingItem) {
                draggedItemVisual.style.left = `${e.clientX}px`; // X position of visual element
                draggedItemVisual.style.top = `${e.clientY}px`; // Y position of visual element
            }
        });

        // Handle dragged item drop (centralized logic)
        document.addEventListener('mouseup', (e) => {
            if (draggingItem) {
                const targetSlotElement = e.target.closest('.inventory-slot'); // Find target slot
                if (targetSlotElement && inventoryOpen) { // Only allow dropping into slots if inventory is open
                    // Dropped into an inventory slot
                    const targetSlotIndex = parseInt(targetSlotElement.dataset.slotIndex);
                    handleInventorySlotDrop(targetSlotIndex);
                } else {
                    // Dropped outside any inventory slot (e.g., onto game canvas or body)
                    // If dropped outside inventory, drop the item at player's location
                    const playerTileX = Math.round(player.x);
                    const playerTileY = Math.round(player.y);

                    // Add item to world materials
                    currentMaterials.push({
                        type: draggingItem.item.type,
                        x: playerTileX,
                        y: playerTileY,
                        collected: false,
                        questionIndex: 0,
                        spawnTime: performance.now()
                    });
                    showMessage(`¬°Soltaste ${materials[draggingItem.item.type].displayName}!`, 1500);
                }
                // Always clear drag state after mouseup
                draggingItem = null;
                draggedItemVisual.style.display = 'none';
                updateInventoryUI(inventoryOpen); // Ensure HTML inventory updates after any drop
            }
        });


        // Touch controls
        document.getElementById('up-button').addEventListener('click', () => { movePlayer(0, -1); });
        document.getElementById('down-button').addEventListener('click', () => { movePlayer(0, 1); });
        document.getElementById('left-button').addEventListener('click', () => { movePlayer(-1, 0); });
        document.getElementById('right-button').addEventListener('click', () => { movePlayer(1, 0); });
        document.getElementById('action-button').addEventListener('click', () => handleAction(false)); // Button action is not a mouse click

        // Game loop
        let lastUpdateTime = 0; // Last time game was updated
        const gameLoop = (currentTime) => {
            const deltaTime = currentTime - lastUpdateTime; // Time elapsed since last update
            lastUpdateTime = currentTime; // Update last update time

            if (!gameRunning) {
                return; // Stop loop if game is not running
            }

            update(currentTime, deltaTime); // Update game state
            draw(); // Draw game

            requestAnimationFrame(gameLoop); // Request next frame
        };

        // Camera variables
        let cameraX = 0;
        let cameraY = 0;

        /**
         * Draws the details of a specific tile onto the given context.
         * This function is used for pre-rendering and for drawing dynamic elements that share a tile appearance.
         * @param {CanvasRenderingContext2D} context - The canvas context to draw on.
         * @param {number} tileType - The type of tile to draw.
         * @param {number} drawX - The X position on the canvas to draw at.
         * @param {number} drawY - The Y position on the canvas to draw at.
         * @param {number} x - The X coordinate of the tile on the map (for flowers).
         * @param {number} y - The Y coordinate of the tile on the map (for flowers).
         */
        const drawTileDetails = (context, tileType, drawX, drawY, x, y) => {
            if (tileType === 1) { // Wall
                context.fillStyle = '#5A2B15'; // Dark brown
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = '#6D351A'; // Lighter brown detail
                context.fillRect(drawX + 1, drawY + 1, TILE_SIZE - 2, TILE_SIZE - 2);
            } else if (tileType === 3) { // Furniture
                context.fillStyle = '#3e2723'; // Dark wood
                context.fillRect(drawX, drawY + TILE_SIZE * 0.4, TILE_SIZE, TILE_SIZE * 0.6); // Base
                context.fillRect(drawX + TILE_SIZE * 0.1, drawY + TILE_SIZE * 0.2, TILE_SIZE * 0.8, TILE_SIZE * 0.2); // Tabletop
            } else if (tileType === 4) { // Water Source
                context.fillStyle = '#ADD8E6'; // Light blue water
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = '#778899'; // Stone basin
                context.fillRect(drawX + TILE_SIZE * 0.1, drawY + TILE_SIZE * 0.1, TILE_SIZE * 0.8, TILE_SIZE * 0.8);
                context.fillStyle = '#42A5F5'; // Water surface
                context.fillRect(drawX + TILE_SIZE * 0.2, drawY + TILE_SIZE * 0.2, TILE_SIZE * 0.6, TILE_SIZE * 0.6);
            } else if (tileType === 5) { // Bulk Soil
                context.fillStyle = '#8B4513'; // Brown soil
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                if (imageLoadedSuccessfully.tierra && loadedImages.tierra) { 
                    context.drawImage(loadedImages.tierra, drawX, drawY, TILE_SIZE, TILE_SIZE); // Use context here instead of ctx
                } else {
                    context.font = `${TILE_SIZE * 0.8}px sans-serif`;
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText('ü™®', drawX + TILE_SIZE / 2, drawY + TILE_SIZE / 2);
                }
            } else if (tileType === 6) { // Patio Floor
                context.fillStyle = '#689f38'; // Greenish-brown
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = 'rgba(0,0,0,0.1)'; // Simple texture
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
            } else if (tileType === 7) { // Door
                context.fillStyle = '#8B4513'; // Brown door
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = '#5C2D16'; // Darker frame
                context.fillRect(drawX, drawY, TILE_SIZE, 2);
                context.fillRect(drawX, drawY + TILE_SIZE - 2, TILE_SIZE, 2);
                context.fillRect(drawX, drawY, 2, TILE_SIZE);
                context.fillRect(drawX + TILE_SIZE - 2, drawY, 2, TILE_SIZE);
                context.fillStyle = '#333'; // Doorknob
                context.fillRect(drawX + TILE_SIZE * 0.75, drawY + TILE_SIZE * 0.45, TILE_SIZE * 0.1, TILE_SIZE * 0.1);
            } else if (tileType === 8) { // Grass
                context.fillStyle = '#4CAF50'; // Green
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = '#66BB6A'; // Lighter grass patches
                context.fillRect(drawX + 2, drawY + 2, TILE_SIZE / 4, TILE_SIZE / 4);
                context.fillRect(drawX + TILE_SIZE - (TILE_SIZE / 4) - 2, drawY + TILE_SIZE - (TILE_SIZE / 4) - 2, TILE_SIZE / 4, TILE_SIZE / 4);
            } else if (tileType === 9) { // Tree - Only trunk, leaves drawn dynamically
                context.fillStyle = '#4CAF50'; // Green background for leaves (part of trunk seen through)
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = '#8B4513'; // Brown trunk
                context.fillRect(drawX + TILE_SIZE * 0.3, drawY + TILE_SIZE * 0.6, TILE_SIZE * 0.4, TILE_SIZE * 0.4);
            } else if (tileType === 10) { // River/Water
                context.fillStyle = '#2196F3'; // Blue water
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = 'rgba(255,255,255,0.2)'; // Simple wave effect
                context.fillRect(drawX, drawY + TILE_SIZE / 3, TILE_SIZE, 1);
                context.fillRect(drawX, drawY + TILE_SIZE * 2 / 3, TILE_SIZE, 1);
            } else if (tileType === 11) { // Path
                context.fillStyle = '#A1887F'; // Light brown
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = 'rgba(0,0,0,0.1)'; // Simple dirt texture
                context.fillRect(drawX + 1, drawY + 1, TILE_SIZE - 2, TILE_SIZE - 2);
            } else if (tileType === 12 || tileType === 13) { // Lakes
                context.fillStyle = '#1E88E5'; // Darker blue for lake
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = 'rgba(255,255,255,0.3)'; // Glare
                context.beginPath();
                context.ellipse(drawX + TILE_SIZE / 2, drawY + TILE_SIZE / 2, TILE_SIZE / 2.5, TILE_SIZE / 4, Math.PI / 4, 0, Math.PI * 2);
                context.fill();
            } else if (tileType === 14) { // Bush
                context.fillStyle = '#388E3C'; // Dark green bush
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = '#4CAF50'; // Lighter green top
                context.beginPath();
                context.ellipse(drawX + TILE_SIZE / 2, drawY + TILE_SIZE / 2, TILE_SIZE / 2, TILE_SIZE / 2.5, 0, 0, Math.PI * 2);
                context.fill();
            } else if (tileType === 15) { // Flower
                context.fillStyle = '#4CAF50'; // Green for stem/background
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = '#388E3C'; // Stem
                context.fillRect(drawX + TILE_SIZE * 0.48, drawY + TILE_SIZE * 0.6, 1, TILE_SIZE * 0.3);
                const flowerColorIndex = (x + y) % flowerColors.length; // Use x, y for color variety
                context.fillStyle = flowerColors[flowerColorIndex]; // P√©talos
                context.beginPath();
                context.arc(drawX + TILE_SIZE / 2, drawY + TILE_SIZE * 0.4, TILE_SIZE * 0.2, 0, Math.PI * 2); 
                context.fill();
                context.fillStyle = '#FFEB3B'; // Centro
                context.beginPath();
                context.arc(drawX + TILE_SIZE / 2, drawY + TILE_SIZE * 0.4, TILE_SIZE * 0.08, 0, Math.PI * 2); 
                context.fill();
            } else if (tileType === 16) { // Bed
                context.fillStyle = '#A0522D'; // Brown bed frame
                context.fillRect(drawX, drawY + TILE_SIZE * 0.6, TILE_SIZE, TILE_SIZE * 0.4);
                context.fillStyle = '#D3D3D3'; // Gray mattress
                context.fillRect(drawX + TILE_SIZE * 0.1, drawY + TILE_SIZE * 0.6, TILE_SIZE * 0.8, TILE_SIZE * 0.2);
                context.fillStyle = '#87CEEB'; // Blue pillow
                context.fillRect(drawX + TILE_SIZE * 0.15, drawY + TILE_SIZE * 0.5, TILE_SIZE * 0.2, TILE_SIZE * 0.1);
                context.fillRect(drawX + TILE_SIZE * 0.65, drawY + TILE_SIZE * 0.5, TILE_SIZE * 0.2, TILE_SIZE * 0.1);
            } else if (tileType === 17) { // Garden Soil
                context.fillStyle = '#964B00'; // Dark brown garden soil
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                context.fillStyle = '#7A3F1A'; // Dirt lines
                context.fillRect(drawX, drawY + TILE_SIZE * 0.2, TILE_SIZE, 1);
                context.fillRect(drawX, drawY + TILE_SIZE * 0.7, TILE_SIZE, 1);
            } else if (tileType === 2) { // Compost Bin (drawn dynamically)
                // Drawn later as a dynamic element
            } else {
                context.fillStyle = '#f5f5dc'; // Default floor color
                context.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
            }
        };

        /**
         * Draws the full static map onto the offscreenCanvas once.
         * Only draws static elements and tree trunks.
         */
        const drawStaticMap = () => {
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const tileType = gameMap[y][x];
                    // DO NOT draw tiles that are dynamic or need to be drawn on top of others
                    // Tiles 2 (compost bin), 18 (planted seed) and 19 (ripe fruit) will be drawn dynamically.
                    // Tree leaves (visual part of tile 9) are drawn separately.
                    // Garden soil (17) is static base, plants are drawn on top.
                    if (tileType !== 2) { // Compost bin is the only static tile that needs special dynamic drawing
                        drawTileDetails(offscreenCtx, tileType, x * TILE_SIZE, y * TILE_SIZE, x, y);
                    }
                }
            }
        };


        // Update game state
        const update = (currentTime, deltaTime) => {
            // Player movement logic based on pressed keys
            if (!questionActive && !dialogueActive && !inventoryOpen) {
                if (keys['arrowup'] || keys['w']) {
                    movePlayer(0, -1);
                } else if (keys['arrowdown'] || keys['s']) {
                    movePlayer(0, 1);
                } else if (keys['arrowleft'] || keys['a']) {
                    movePlayer(-1, 0);
                } else if (keys['arrowright'] || keys['d']) {
                    movePlayer(1, 0);
                }
            }

            // Day/Night system update
            const totalGameTimeElapsed = (currentTime - gameStartTime) / 1000; // Total game time elapsed in seconds
            const timeIntoCycle = totalGameTimeElapsed % totalCycleDurationSeconds; // Time elapsed in current cycle
            const previousIsNight = isNight; // Save previous night state
            let remainingTimeInPhase; // Time remaining in current phase

            if (timeIntoCycle < dayDurationSeconds) {
                isNight = false; // It's daytime
                remainingTimeInPhase = dayDurationSeconds - timeIntoCycle; // Time remaining in day
            } else {
                isNight = true; // It's nighttime
                remainingTimeInPhase = totalCycleDurationSeconds - timeIntoCycle; // Time remaining in night
            }

            // Check for phase transition (Day -> Night)
            if (isNight && !previousIsNight) {
                showMessage('¬°Ha ca√≠do la noche! ¬°Cuidado con los monstruos!', 2000);
                // Ensure player has a sword at night, add it if not
                const hasSword = player.inventory.some(item => item && materials[item.type].type === 'weapon');
                if (!hasSword) {
                    addItemToInventory('sword', 1);
                }
            }
            // Check for phase transition (Night -> Day) - Automatic day progression
            else if (!isNight && previousIsNight) {
                gameDay++; // Increment game day
                dayCounterSpan.textContent = `${gameDay}`; // Update day counter
                monsters = []; // Limpiar monstruos al amanecer
                respawnMaterials(); // Regenerar materiales
                updateFarmPlotGrowth(); // Actualizar el crecimiento de las plantas al inicio del d√≠a
                if (gameDay > TOTAL_GAME_DAYS) { // Check for game end after TOTAL_GAME_DAYS
                    gameRunning = false;
                    if (compostPile.count === compostPile.maxCount) {
                        showMessage(`¬°Juego Terminado! ¬°Creaste compost perfecto en ${TOTAL_GAME_DAYS} d√≠as!`, 5000);
                        if (elara.missionAccepted) {
                            showMessage("Elara: '¬°Lo lograste! La tierra vuelve a la vida. ¬°Gracias, campe√≥n!'", 5000);
                        }
                    } else {
                        showMessage(`¬°Juego Terminado! No lograste completar el compost. Compost: ${compostPile.count}/${compostPile.maxCount}`, 5000);
                            if (elara.missionAccepted && compostPile.count < compostPile.maxCount) {
                                showMessage("Elara: 'No logramos restaurar la tierra a tiempo. Pero la esperanza perdura. Quiz√°s otro d√≠a...'", 5000);
                            }
                        }
                } else {
                    showMessage(`¬°El d√≠a ${gameDay} ha comenzado!`, 2000);
                }
            }

            // Update UI for time and phase
            dayTimerSpan.textContent = `${Math.floor(remainingTimeInPhase / 60).toString().padStart(2, '0')}:${Math.floor(remainingTimeInPhase % 60).toString().padStart(2, '0')}`;
            phaseIndicatorSpan.textContent = isNight ? 'Noche' : 'D√≠a';

            // Handle player movement interpolation
            handlePlayerMovement(deltaTime);

            // Health regeneration
            if (player.health < player.maxHealth) {
                const timePassedSinceLastRegen = currentTime - player.lastHealthRegenTime;
                if (timePassedSinceLastRegen >= 1000) { // Regenerate every second
                    const regenAmount = player.healthRegenRate * (timePassedSinceLastRegen / 1000);
                    player.health = Math.min(player.maxHealth, player.health + regenAmount);
                    player.lastHealthRegenTime = currentTime;
                }
            }

            // Player health check and respawn
            if (player.health <= 0) {
                player.health = player.maxHealth; // Reset health
                player.x = respawnPoint.x; // Respawn at respawn point
                player.y = respawnPoint.y;
                player.targetX = respawnPoint.x;
                player.targetY = respawnPoint.y;
                monsters = []; // Clear monsters when player dies
                showMessage('¬°Fuiste derrotado! Reapareciste en casa.', 3000);
            }

            // Monster spawn logic (only at night)
            if (isNight && currentTime - lastMonsterSpawnTime >= MONSTER_SPAWN_INTERVAL_MS && monsters.length < MAX_ACTIVE_MONSTERS) {
                spawnRandomMonster(); // Generate a new monster
                lastMonsterSpawnTime = currentTime; // Update last spawn time
            }

            // Monster movement and attack logic
            monsters = monsters.filter(monster => {
                if (monster.health <= 0) {
                    // If monster dies, drop an item if it has a defined drop
                    dropRandomSeed(monster); // Call seed drop function
                    return false; // Remove dead monsters
                }

                // Move monster towards player
                const dx = player.x - monster.x;
                const dy = player.y - monster.y;
                const distance = getDistance(monster.x, monster.y, player.x, player.y);

                if (distance > TILE_SIZE / 2) { // Only move if not adjacent
                    const moveDistance = monster.speed * deltaTime;
                    monster.x += (dx / distance) * moveDistance;
                    monster.y += (dy / distance) * moveDistance;
                }

                // Attack player if close enough and cooldown is ready
                if (distance < TILE_SIZE && (currentTime - monster.lastAttackTime) > monster.attackCooldown) {
                    player.health -= monster.damage; // Reduce player health
                    monster.lastAttackTime = currentTime; // Update monster's last attack time
                    showMessage(`¬°El ${monster.type} te atac√≥! Salud: ${player.health}`, 1000);
                }
                return true; // Keep monster alive
            });

            // Update damage popups
            for (let i = damagePopups.length - 1; i >= 0; i--) {
                const popup = damagePopups[i];
                const age = currentTime - popup.startTime;
                if (age > 1000) { // Remove after 1 second
                    popup.element.remove();
                    damagePopups.splice(i, 1);
                } else {
                    // Update position and opacity (CSS animation handles this, just ensure position is updated)
                    // The CSS animation handles the floatUpFadeOut effect.
                    // We just need to make sure the element is positioned correctly initially.
                }
            }


            // Material spawn logic
            if (currentTime - lastMaterialSpawnTime >= MATERIAL_SPAWN_INTERVAL_MS && currentMaterials.filter(m => !m.collected && materialPool.includes(m.type)).length < MAX_ACTIVE_MATERIALS) {
                spawnRandomMaterial(); // Generate a new material
                lastMaterialSpawnTime = currentTime; // Update last spawn time
            }

            // Material despawn logic
            currentMaterials = currentMaterials.filter(mat => {
                if (mat.collected) return true; // Keep collected materials
                if (materialPool.includes(mat.type) && currentTime - mat.spawnTime > MATERIAL_DESPAWN_TIME_MS) {
                    showMessage(`${materials[mat.type].displayName} desapareci√≥! No lo recogiste a tiempo.`, 1500);
                    return false; // Remove material if expired
                }
                return true; // Keep material active
            });


            // Question resolution logic
            if (questionActive) {
                const timeRemaining = Math.max(0, QUESTION_DURATION_MS - (currentTime - questionStartTime)); // Time remaining for question
                questionTimerElement.textContent = `Tiempo: ${Math.ceil(timeRemaining / 1000)}s`; // Update timer

                if (timeRemaining <= 0) {
                    resolveQuestion(); // Resolve question if time runs out
                }
            }
        };

        // NEW: Function to drop a random seed from a monster
        function dropRandomSeed(monster) {
            let randomValue = Math.random();
            let cumulativeProbability = 0;
            let droppedSeedType = null;

            for (const seedType of herbSeedTypes) {
                cumulativeProbability += herbSeedProbabilities[seedType];
                if (randomValue < cumulativeProbability) {
                    droppedSeedType = seedType;
                    break;
                }
            }

            if (droppedSeedType) {
                addItemToInventory(droppedSeedType, 1);
                showMessage(`¬°El ${monster.type} solt√≥ una ${materials[droppedSeedType].displayName}!`, 1500);
            } else {
                showMessage(`¬°El ${monster.type} no solt√≥ nada esta vez!`, 1500);
            }
        }


        // Draw everything on the canvas
        const draw = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            // Calculate camera position to center it on the player
            cameraX = Math.max(0, Math.min(player.x * TILE_SIZE - ACTUAL_CANVAS_WIDTH / 2, MAP_WIDTH * TILE_SIZE - ACTUAL_CANVAS_WIDTH));
            cameraY = Math.max(0, Math.min(player.y * TILE_SIZE - ACTUAL_CANVAS_HEIGHT / 2, MAP_HEIGHT * TILE_SIZE - ACTUAL_CANVAS_HEIGHT));

            // Draw pre-rendered static map (includes tree trunks)
            ctx.drawImage(offscreenCanvas, cameraX, cameraY, ACTUAL_CANVAS_WIDTH, ACTUAL_CANVAS_HEIGHT, 0, 0, ACTUAL_CANVAS_WIDTH, ACTUAL_CANVAS_HEIGHT);

            // Draw dynamic elements that change and need to be drawn on top of the static map
            // Compost bin (tile 2)
            const compostDrawX = compostPile.x * TILE_SIZE - cameraX;
            const compostDrawY = compostPile.y * TILE_SIZE - cameraY;
            if (compostDrawX + TILE_SIZE > 0 && compostDrawX < ACTUAL_CANVAS_WIDTH &&
                compostDrawY + TILE_SIZE > 0 && compostDrawY < ACTUAL_CANVAS_HEIGHT) { // Only draw if visible
                if (imageLoadedSuccessfully.compost_bin && loadedImages.compost_bin) {
                    ctx.drawImage(loadedImages.compost_bin, compostDrawX, compostDrawY, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.fillStyle = '#455A64'; // Dark gray bin
                    ctx.fillRect(compostDrawX, compostDrawY, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = '#607D8B'; // Lighter top edge
                    ctx.fillRect(compostDrawX, compostDrawY, TILE_SIZE, TILE_SIZE * 0.1);
                }

                // Compost fill
                const compostFillHeight = (compostPile.count / compostPile.maxCount) * TILE_SIZE * 0.8;
                ctx.fillStyle = '#3E2723'; // Compost brown
                ctx.fillRect(compostDrawX + TILE_SIZE * 0.1, compostDrawY + TILE_SIZE - compostFillHeight, TILE_SIZE * 0.8, compostFillHeight);

                ctx.font = `${TILE_SIZE * 0.6}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                let stateEmoji = '';
                switch (compostState) {
                    case COMPOST_STATES.NEEDS_SOIL: stateEmoji = 'ü™®'; break;
                    case COMPOST_STATES.NEEDS_MATERIAL: stateEmoji = 'üçé'; break;
                    case COMPOST_STATES.NEEDS_WATER: stateEmoji = 'üíß'; break;
                    case COMPOST_STATES.NEEDS_STIR: stateEmoji = 'üîÑ'; break;
                    case COMPOST_STATES.FULL: stateEmoji = '‚úÖ'; break;
                }
                ctx.fillText(stateEmoji, compostDrawX + TILE_SIZE / 2, compostDrawY + TILE_SIZE / 2);
            }

            // Draw materials (adjusted for camera offset)
            currentMaterials.forEach(mat => {
                if (!mat.collected) {
                    const materialDef = materials[mat.type];
                    const drawX = mat.x * TILE_SIZE - cameraX;
                    const drawY = mat.y * TILE_SIZE - cameraY;
                    if (drawX + TILE_SIZE > 0 && drawX < ACTUAL_CANVAS_WIDTH &&
                        drawY + TILE_SIZE > 0 && drawY < ACTUAL_CANVAS_HEIGHT) { // Only draw if visible
                        if (imageLoadedSuccessfully[mat.type] && loadedImages[mat.type]) {
                            ctx.drawImage(loadedImages[mat.type], drawX, drawY, TILE_SIZE, TILE_SIZE);
                        } else {
                            ctx.font = `${TILE_SIZE * 0.9}px sans-serif`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillStyle = '#f5f5dc'; // Fallback background
                            ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = 'black';
                            ctx.fillText(materialDef.emoji, drawX + TILE_SIZE / 2, drawY + TILE_SIZE / 2);
                        }
                    }
                }
            });

            // Draw NPCs (adjusted for camera offset)
            [elara, silasVane, compostGuru].forEach(npc => { // Added compostGuru to NPC list
                const npcDrawX = npc.x * TILE_SIZE - cameraX;
                const npcDrawY = npc.y * TILE_SIZE - cameraY;
                if (npcDrawX + TILE_SIZE > 0 && npcDrawX < ACTUAL_CANVAS_WIDTH &&
                    npcDrawY + TILE_SIZE > 0 && npcDrawY < ACTUAL_CANVAS_HEIGHT) { // Only draw if visible
                    ctx.fillStyle = npc.color;
                    ctx.fillRect(npcDrawX, npcDrawY, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(npcDrawX, npcDrawY, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(npcDrawX + 2, npcDrawY + 2, TILE_SIZE - 4, TILE_SIZE - 4); // For depth effect

                    ctx.font = `${TILE_SIZE * 0.9}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'white';
                    ctx.fillText(npc.emoji, npcDrawX + TILE_SIZE / 2, npcDrawY + TILE_SIZE / 2);
                }
            });

            // Draw monsters
            monsters.forEach(monster => {
                const monsterDrawX = monster.x * TILE_SIZE - cameraX;
                const monsterDrawY = monster.y * TILE_SIZE - cameraY;
                if (monsterDrawX + TILE_SIZE > 0 && monsterDrawX < ACTUAL_CANVAS_WIDTH &&
                    monsterDrawY + TILE_SIZE > 0 && monsterDrawY < ACTUAL_CANVAS_HEIGHT) { // Only draw if visible
                    
                    // Apply hit flash effect if recently hit
                    if (performance.now() - monster.lastHitTime < monster.hitFlashTime) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Red tint
                        ctx.fillRect(monsterDrawX, monsterDrawY, TILE_SIZE, TILE_SIZE);
                    }

                    ctx.fillStyle = monster.color;
                    ctx.fillRect(monsterDrawX, monsterDrawY, TILE_SIZE, TILE_SIZE);
                    ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'white';
                    ctx.fillText(monster.emoji, monsterDrawX + TILE_SIZE / 2, monsterDrawY + TILE_SIZE / 2);
                }
            });

            // Draw planted farm plots
            plantedFarmPlots.forEach(plot => {
                const plotDrawX = plot.x * TILE_SIZE - cameraX;
                const plotDrawY = plot.y * TILE_SIZE - cameraY;

                if (plotDrawX + TILE_SIZE > 0 && plotDrawX < ACTUAL_CANVAS_WIDTH &&
                    plotDrawY + TILE_SIZE > 0 && plotDrawY < ACTUAL_CANVAS_HEIGHT) {

                    const seedDef = materials[plot.plantedSeed];
                    let plantItemName = seedDef.growsTo; // The name of the item it grows into

                    // Determine plant image/emoji based on growth stage
                    let imageToDraw = null;
                    let emojiToDraw = seedDef.emoji; // Default to seed emoji

                    if (plot.growthStage >= seedDef.growthTime) {
                        // Ripe plant, use the image of the harvested item
                        imageToDraw = loadedImages[plantItemName];
                        emojiToDraw = materials[plantItemName].emoji;
                    } else if (plot.growthStage > 0) {
                        // Intermediate growth stage, use a generic plant seedling or small version
                        emojiToDraw = 'üå±'; // Generic small plant
                    } else {
                        // Just planted, show the seed itself
                        imageToDraw = loadedImages[plot.plantedSeed];
                        emojiToDraw = seedDef.emoji;
                    }

                    // Draw image if available, otherwise draw emoji
                    if (imageToDraw && imageLoadedSuccessfully[imageToDraw.src.substring(imageToDraw.src.lastIndexOf('/') + 1, imageToDraw.src.lastIndexOf('.'))]) {
                        ctx.drawImage(imageToDraw, plotDrawX, plotDrawY, TILE_SIZE, TILE_SIZE);
                    } else if (emojiToDraw) { 
                        // Fallback to emoji for plants
                        ctx.font = `${TILE_SIZE * 0.9}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = 'black'; // Or plant-specific color
                        ctx.fillText(emojiToDraw, plotDrawX + TILE_SIZE / 2, plotDrawY + TILE_SIZE / 2);
                    }

                    // Draw growth progress text
                    if (plot.growthStage < seedDef.growthTime) {
                         ctx.font = 'bold 8px Inter, sans-serif';
                         ctx.textAlign = 'left';
                         ctx.textBaseline = 'top';
                         ctx.fillStyle = 'rgba(0,0,0,0.7)';
                         ctx.fillText(`${plot.growthStage}/${seedDef.growthTime}`, plotDrawX + 2, plotDrawY + 2);
                    } else {
                         ctx.font = 'bold 10px Inter, sans-serif';
                         ctx.textAlign = 'left';
                         ctx.textBaseline = 'top';
                         ctx.fillStyle = 'rgba(0,100,0,0.9)';
                         ctx.fillText('Listo', plotDrawX + 2, plotDrawY + 2);
                    }

                    // Draw watered status overlay
                    if (!plot.watered && plot.lastWateredDay < gameDay) {
                        ctx.fillStyle = 'rgba(255,165,0,0.3)'; // Orange transparent overlay for needs water
                        ctx.fillRect(plotDrawX, plotDrawY, TILE_SIZE, TILE_SIZE);
                    } else if (plot.watered && plot.lastWateredDay === gameDay) {
                        ctx.fillStyle = 'rgba(0,200,0,0.1)'; // Light green transparent overlay for watered today
                        ctx.fillRect(plotDrawX, plotDrawY, TILE_SIZE, TILE_SIZE);
                    }
                }
            });


            // Draw player (adjusted for camera offset)
            const playerDrawX = player.x * TILE_SIZE - cameraX;
            const playerDrawY = player.y * TILE_SIZE - cameraY;

            ctx.save(); // Save current context state

            ctx.translate(playerDrawX + TILE_SIZE / 2, playerDrawY + TILE_SIZE / 2); // Move origin to player's center

            // Flip player sprite based on direction: If player.direction is 'left', flip horizontally.
            if (player.direction === 'left') { 
                ctx.scale(-1, 1); // Flip horizontally
            }

            const drawOriginX = -TILE_SIZE / 2; // Drawing origin X relative to player's center
            const drawOriginY = -TILE_SIZE / 2; // Drawing origin Y relative to player's center

            if (imageLoadedSuccessfully.player && loadedImages.player) {
                ctx.drawImage(loadedImages.player, drawOriginX, drawOriginY, TILE_SIZE, TILE_SIZE);
            } else {
                // Fallback drawing for player
                ctx.fillStyle = '#f5f5dc'; // Ground color
                ctx.fillRect(drawOriginX, drawOriginY, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = '#4CAF50'; // Green for body
                ctx.fillRect(drawOriginX + TILE_SIZE * 0.25, drawOriginY + TILE_SIZE * 0.4, TILE_SIZE * 0.5, TILE_SIZE * 0.4);
                ctx.fillStyle = '#E65100'; // Orange for head
                ctx.fillRect(drawOriginX + TILE_SIZE * 0.3, drawOriginY + TILE_SIZE * 0.1, TILE_SIZE * 0.4, TILE_SIZE * 0.3);
                ctx.fillStyle = '#000000';
                ctx.fillRect(drawOriginX + TILE_SIZE * 0.35, drawOriginY + TILE_SIZE * 0.2, 2, 2); // Left eye
                ctx.fillRect(drawOriginX + TILE_SIZE * 0.6 - 1, drawOriginY + TILE_SIZE * 0.2, 2, 2); // Right eye
                ctx.fillStyle = '#795548'; // Brown for legs
                ctx.fillRect(drawOriginX + TILE_SIZE * 0.25, drawOriginY + TILE_SIZE * 0.8, TILE_SIZE * 0.2, TILE_SIZE * 0.2);
                ctx.fillRect(drawOriginX + TILE_SIZE * 0.55, drawOriginY + TILE_SIZE * 0.8, TILE_SIZE * 0.2, TILE_SIZE * 0.2);
                ctx.fillStyle = '#4CAF50'; // Arms
                ctx.fillRect(drawOriginX + TILE_SIZE * 0.15, drawOriginY + TILE_SIZE * 0.45, TILE_SIZE * 0.1, TILE_SIZE * 0.3);
                ctx.fillRect(drawOriginX + TILE_SIZE * 0.75, drawOriginY + TILE_SIZE * 0.45, TILE_SIZE * 0.1, TILE_SIZE * 0.3);
            }

            // Draw active item held by player in hand
            const activeItem = player.inventory[player.activeSlotIndex];
            if (activeItem) {
                const heldItemDef = materials[activeItem.type];
                const itemSize = TILE_SIZE * 0.5; // Item occupies 50% of tile size (smaller)

                // Position of item relative to player's center (0,0 in this transformed context)
                // Adjusted so item appears in the "correct" hand
                let itemPositionX = TILE_SIZE * 0.2; // Offset from player's center towards their right hand
                let itemPositionY = TILE_SIZE * 0.15; // Vertical offset from player's center

                // If player is facing left, item should appear in left hand
                if (player.direction === 'left') {
                    itemPositionX = -TILE_SIZE * 0.2; // Offset to the left
                }

                if (heldItemDef && imageLoadedSuccessfully[activeItem.type] && loadedImages[activeItem.type]) {
                    ctx.drawImage(loadedImages[activeItem.type], itemPositionX - itemSize / 2, itemPositionY - itemSize / 2, itemSize, itemSize);
                } else if (heldItemDef) {
                    ctx.font = `${itemSize * 0.9}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'black';
                    // Adjustment so emoji draws within the flip transform
                    ctx.fillText(heldItemDef.emoji, itemPositionX / (player.direction === 'left' ? -1 : 1), itemPositionY + itemSize / 2);
                }
            }
            ctx.restore(); // Restore context state (undoes translation and flip)

            // Draw tree leaves AFTER player to cover them
            treeLocations.forEach(tree => {
                const leavesWidth = TILE_SIZE * 2.5;
                const leavesHeight = TILE_SIZE * 2.0; // Adjusted to cover more vertically
                const leavesDrawX = tree.x * TILE_SIZE - cameraX + (TILE_SIZE - leavesWidth) / 2;
                const leavesDrawY = tree.y * TILE_SIZE - cameraY - TILE_SIZE; // Adjusted to lower leaves

                // Only draw leaves if tree base is within visible range
                if (tree.x * TILE_SIZE - cameraX + TILE_SIZE > 0 && tree.x * TILE_SIZE - cameraX < ACTUAL_CANVAS_WIDTH &&
                    tree.y * TILE_SIZE - cameraY + TILE_SIZE > 0 && tree.y * TILE_SIZE - cameraY < ACTUAL_CANVAS_HEIGHT) {
                    
                    ctx.fillStyle = '#388E3C'; // Dark green for leaves
                    ctx.beginPath();
                    ctx.ellipse(leavesDrawX + leavesWidth / 2, leavesDrawY + leavesHeight / 2, leavesWidth / 2, leavesHeight / 2, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#4CAF50'; // Lighter green on top
                    ctx.beginPath();
                    ctx.ellipse(leavesDrawX + leavesWidth / 2, leavesDrawY + leavesHeight * 0.4, leavesWidth / 2.2, leavesHeight / 2.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });


            // Draw mouse crosshair if visible
            if (crosshair.visible) {
                const crosshairDrawX = crosshair.x * TILE_SIZE - cameraX;
                const crosshairDrawY = crosshair.y * TILE_SIZE - cameraY;

                ctx.strokeStyle = '#FFFF00'; // Yellow color
                ctx.lineWidth = 2;

                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(crosshairDrawX + TILE_SIZE * 0.1, crosshairDrawY + TILE_SIZE / 2);
                ctx.lineTo(crosshairDrawX + TILE_SIZE * 0.9, crosshairDrawY + TILE_SIZE / 2);
                ctx.stroke();

                // Vertical line
                ctx.beginPath();
                ctx.moveTo(crosshairDrawX + TILE_SIZE / 2, crosshairDrawY + TILE_SIZE * 0.1);
                ctx.lineTo(crosshairDrawX + TILE_SIZE / 2, crosshairDrawY + TILE_SIZE * 0.9);
                ctx.stroke();
            }

            // Apply night overlay
            if (isNight) {
                ctx.fillStyle = 'rgba(0, 0, 50, 0.5)'; // Dark blue transparent overlay
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Update UI elements
            compostCountSpan.textContent = compostPile.count;
            compostMaxSpan.textContent = compostPile.maxCount;
            let stateText = '';
            switch (compostState) {
                case COMPOST_STATES.NEEDS_SOIL: stateText = 'Esperando tierra'; break;
                case COMPOST_STATES.NEEDS_MATERIAL: stateText = 'Esperando material org√°nico'; break;
                case COMPOST_STATES.NEEDS_WATER: stateText = 'Necesita agua'; break;
                case COMPOST_STATES.NEEDS_STIR: stateText = 'Necesita ser revuelto'; break;
                case COMPOST_STATES.FULL: stateText = '¬°Compost listo!'; break;
            }
            compostStateSpan.textContent = stateText;

            // Update player health UI
            healthValueSpan.textContent = Math.round(player.health); // Round for display
            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;

            // Draw hotbar on Canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // Dark transparent background
            ctx.roundRect(HOTBAR_START_X, HOTBAR_START_Y, HOTBAR_WIDTH, HOTBAR_HEIGHT, 10);
            ctx.fill();
            ctx.strokeStyle = '#8B4513'; // Brown border
            ctx.lineWidth = 2;
            ctx.roundRect(HOTBAR_START_X, HOTBAR_START_Y, HOTBAR_WIDTH, HOTBAR_HEIGHT, 10);
            ctx.stroke();

            // Draw active item name above hotbar
            const activeItemInHotbar = player.inventory[player.activeSlotIndex]; // Get active item to display its name
            const activeItemName = activeItemInHotbar ? materials[activeItemInHotbar.type].displayName : 'Ninguno';
            ctx.font = 'bold 16px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.fillText(activeItemName, ACTUAL_CANVAS_WIDTH / 2, HOTBAR_START_Y - 10); // Position above hotbar

            // Draw individual hotbar slots
            for (let i = 0; i < 4; i++) {
                const slotX = HOTBAR_START_X + HOTBAR_PADDING + (i * (HOTBAR_SLOT_SIZE + HOTBAR_SLOT_SPACING));
                const slotY = HOTBAR_START_Y + HOTBAR_PADDING;

                // Draw slot background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; // Lighter transparent background for slots
                ctx.roundRect(slotX, slotY, HOTBAR_SLOT_SIZE, HOTBAR_SLOT_SIZE, 8);
                ctx.fill();

                // Draw slot border
                ctx.strokeStyle = '#66BB6A'; // Green border
                ctx.lineWidth = 2;
                ctx.roundRect(slotX, slotY, HOTBAR_SLOT_SIZE, HOTBAR_SLOT_SIZE, 8);
                ctx.stroke();

                // Draw active slot indicator
                if (player.activeSlotIndex === i) {
                    ctx.strokeStyle = '#FFEB3B'; // Yellow for active slot
                    ctx.lineWidth = 4; // Thicker border for active slot
                    ctx.roundRect(slotX, slotY, HOTBAR_SLOT_SIZE, HOTBAR_SLOT_SIZE, 8);
                    ctx.stroke();
                }

                // Draw item in slot
                const item = player.inventory[i];
                if (item) {
                    const itemDef = materials[item.type];
                    if (itemDef) {
                        const itemDrawSize = HOTBAR_SLOT_SIZE * 0.7; // Item takes 70% of slot size
                        const itemDrawX = slotX + (HOTBAR_SLOT_SIZE - itemDrawSize) / 2;
                        const itemDrawY = slotY + (HOTBAR_SLOT_SIZE - itemDrawSize) / 2;

                        if (imageLoadedSuccessfully[item.type] && loadedImages[item.type]) {
                            ctx.drawImage(loadedImages[item.type], itemDrawX, itemDrawY, itemDrawSize, itemDrawSize);
                        } else {
                            ctx.font = `${itemDrawSize * 0.9}px sans-serif`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillStyle = 'white';
                            ctx.fillText(itemDef.emoji, slotX + HOTBAR_SLOT_SIZE / 2, slotY + HOTBAR_SLOT_SIZE / 2);
                        }

                        // Draw item count
                        if (item.count > 1) {
                            ctx.font = 'bold 12px Inter, sans-serif';
                            ctx.textAlign = 'right';
                            ctx.textBaseline = 'bottom';
                            ctx.fillStyle = 'white';
                            ctx.fillText(item.count.toString(), slotX + HOTBAR_SLOT_SIZE - 5, slotY + HOTBAR_SLOT_SIZE - 5);
                        }
                    }
                }
            }
        };

        // NEW: Farm plot functions (now integrated into game logic and drawing)
        /**
         * Updates the growth of plants in the farm plots at the start of a new day.
         * This function iterates through the plantedFarmPlots array.
         */
        const updateFarmPlotGrowth = () => {
            // Iterate in reverse to safely remove withered plots
            for (let i = plantedFarmPlots.length - 1; i >= 0; i--) {
                const plot = plantedFarmPlots[i];
                if (plot.plantedSeed) {
                    const plantDef = materials[plot.plantedSeed];
                    
                    // Check for growth
                    // Plant grows if it was watered yesterday (lastWateredDay === gameDay - 1) AND hasn't grown today (lastGrowthDay < gameDay)
                    if (plot.watered && plot.lastWateredDay === gameDay - 1 && plot.lastGrowthDay < gameDay) {
                        plot.growthStage++;
                        plot.lastGrowthDay = gameDay; // Register growth day
                        showMessage(`¬°Tu ${plantDef.displayName} en (${plot.x},${plot.y}) ha crecido al d√≠a ${plot.growthStage}!`, 1500);
                    } 
                    // Check for wilting (if not watered yesterday or today)
                    else if (!plot.watered && plot.lastWateredDay < gameDay -1 && plot.growthStage > 0) { 
                        if (Math.random() < 0.2) { // 20% chance to wither
                            showMessage(`¬°Tu ${plantDef.displayName} en (${plot.x},${plot.y}) se marchit√≥ por falta de agua!`, 2000);
                            plantedFarmPlots.splice(i, 1); // Remove withered plot
                            continue; // Skip to next iteration as plot is removed
                        }
                    }
                    plot.watered = false; // Reset watered status for the new day
                }
            }
        };

        // Inicializar juego
        window.onload = function() {
            // A√±adir un m√©todo roundRect a CanvasRenderingContext2D si no existe (para navegadores m√°s antiguos)
            if (!CanvasRenderingContext2D.prototype.roundRect) {
                CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                    if (typeof radius === 'undefined') {
                        radius = 5; // Radio por defecto
                    }
                    this.beginPath();
                    this.moveTo(x + radius, y);
                    this.lineTo(x + width - radius, y);
                    this.quadraticCurveTo(x + width, y, x + width, y + radius);
                    this.lineTo(x + width, y + height - radius);
                    this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    this.lineTo(x + radius, y + height);
                    this.quadraticCurveTo(x, y + height, x, y + height - radius);
                    this.lineTo(x, y + radius);
                    this.quadraticCurveTo(x, y, x + radius, y);
                    this.closePath();
                };
            }
            // La inicializaci√≥n del juego se maneja dentro de checkAllAssetsLoaded
            // para asegurar que todos los recursos se hayan intentado cargar.
            // Esto asegura que la p√°gina de carga se muestre hasta que todo est√© listo.
        };
    </script>
</body>
</html>
